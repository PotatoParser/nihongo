<!DOCTYPE HTML>
<html>
<body style="overflow: hidden; margin: none; border: none; outline: none">
	<style>
	canvas{
		outline: 5px solid black;
	}
	html{
		cursor: url("cursor.png") 8 8, pointer;
	}
	div{
		position: fixed;
		top: 10px;
		font-size: 40px;
		left: 10px;
		user-select: none;
		pointer-events: none;
	}
</style>
<div id="FPS">0</div>
	<script>
		// (C) Wilson Nguyen
		// Faster method if you create a queue mechanic
		function canvasGen(){
			var temp = document.createElement("CANVAS");
			temp.id = "screen";
			temp.width = window.innerHeight-20;
			temp.height = window.innerHeight-20;
			temp.style=`position: fixed; top: 10px; left: ${(window.innerHeight-20)/2}px;`;
			document.body.appendChild(temp);
			return {
				width: window.innerHeight-20,
				height: window.innerHeight-20,
				x: (window.innerHeight-20)/2,
				y: 10,
				ctx: temp.getContext("2d"),
			}
		}
		function createEntity(){

		}
	</script>
	<script>
		async function loadImages(arrImages){
			var temp = {};
			for (var i = 0; i < arrImages.length; i++) {
				var other = new Image();
				other.src = arrImages[i];
				await new Promise((resolve)=>{
					other.onload = ()=>{
						resolve();
					}
				});
				temp[arrImages[i]] = other;
			}
			return temp;
		}
		var allEntities = {};
		var allCol = [];
		class key{
			constructor(keyCode, whenDown, whenUp, speed){
				this.mainKey = keyCode;
				this.keyDown = false;
				this.whenDown = (e)=>{
					if (e.code != this.mainKey) return;
					if (!this.keyDown) {
						this.keyDown = true;
						whenDown();
						if (speed != 0) this.keyDown = setInterval(whenDown, speed);
					}
				};
				this.whenUp = (e)=>{
					if (e.code != this.mainKey) return;					
					if (this.keyDown) {
						whenUp();
						if (speed != 0) clearInterval(this.keyDown);
						this.keyDown = false;
					}
				};
				document.addEventListener("keydown", this.whenDown);
				document.addEventListener("keyup", this.whenUp);
			}
			destroy(){
				if (this.keyDown) clearInterval(this.keyDown);
				document.removeEventListener("keydown", this.whenDown);
				document.removeEventListener("keyup", this.whenUp);
				delete this;
			}
		}
		function distance(x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
		}		
		function ERR(actual, calc){
			if (Math.round(actual) == Math.round(calc)) console.log("PERFECT");
			else console.log(Math.round((actual-calc)/calc*100) + "%");
		}
		class entity{
			constructor(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				this.img = image;
				this.x = x || 0;
				this.y = y || 0;
				this.height = height || image[0].height;
				this.width = width || image[0].width;			
				this.index = 0;
				this.speed = 1;
				this.moveToLoop = false;
				this.id = Symbol();
				this.prop = {};
				this.hit = {
					offX: offsetX || 0,
					offY: offsetY || 0,
					offWidth: (hitWidth || this.width),
					offHeight: (hitHeight || this.height),
				}
				this.collisionEvent = [];
				this.colArea = {
					x: [],
					y: []
				}
				this.still = false,
				allEntities[this.id] = this;				
			}
			draw(ctx){
				if (!this.still) ctx.drawImage(this.img[this.index], this.x-this.hit.offX, this.y-this.hit.offY, this.width, this.height);
			}
			tp(x,y){
				this.x = x;
				this.y = y;
			}
			moveX(newX){
				if (newX < this.x) this.x = this.checkAllX(this.y, this.x, newX, this, (c,o)=>{});
				else this.x = this.checkAllX(this.y, this.x, newX+this.hit.offWidth, this, (c,o)=>{})-this.hit.offWidth;				
			}			
			moveY(newY){
				if (newY < this.y) this.y = this.checkAllY(this.x, this.y, newY, this, (c,o)=>{});
				else this.y = this.checkAllY(this.x, this.y, newY+this.hit.offHeight, this, (c,o)=>{})-this.hit.offHeight;
			}			
			moveTo(x, y, reach){
				//One pixel every frame
				this.stopMoving();
				var rise = y-this.y, run = x-this.x, dist = distance(x,y,this.x,this.y), xPos = 1, yPos = 1;
				if (rise < 0) yPos = -1;
				if (run < 0) xPos = -1;
				this.moveToLoop = true;
				this.moveToLoop = setInterval(()=>{
					var tempY = this.y + rise/dist*this.speed;
					var tempX = this.x + run/dist*this.speed;
					if ((tempX-x)*xPos >= 0 && (tempY-y)*yPos >= 0){ // -x means that tempY is negative 
						if (!reach) {
							this.moveY(y);
							this.moveX(x);
							this.stopMoving();							
							return;
						} else reach(this,x,y);
					}
					this.moveY(tempY);
					this.moveX(tempX);
				}, 1000/60);
			}					
			stopMoving(){
				// Not currently rounding!!!!
				if (this.moveToLoop) {
					clearInterval(this.moveToLoop);
					this.moveToLoop = false;
				}
			}
			oncollision(func){
				this.collisionEvent.push(func);
			}
			checkAllY(x, y1, y2){
				var allEnt = Object.getOwnPropertySymbols(allEntities);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;		
					for (var i = 0; i < allEntities[allEnt[b]].colArea.y.length; i++) {
						var temp = allEntities[allEnt[b]].colArea.y[i].check(x, y1, y2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								console.log(temp);
								var atImpact = this.collisionEvent[a](this, temp.impact);
								if (atImpact) return atImpact;
							}
						}
						y2 = temp.y;
					}
				}
				return y2;
			}
			checkAllX(y, x1, x2){
				var allEnt = Object.getOwnPropertySymbols(allEntities);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;	
					for (var i = 0; i < allEntities[allEnt[b]].colArea.x.length; i++) {
						var temp = allEntities[allEnt[b]].colArea.x[i].check(y, x1, x2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								var atImpact = this.collisionEvent[a](this, temp.impact);
								if (atImpact) return atImpact;
							}
						}		
						x2 = temp.x;
					}
				}
				return x2;
			}		
			destroy(){
				if (this.moveToLoop) clearInterval(this.moveToLoop);
				delete allEntities[this.id];				
				delete this;
			}
			addCollision(x, y, distance, direction){
				switch(direction) {
					case "y": this.colArea.x.push(new wall(x, y, distance, direction, this)); break;
					case "x": this.colArea.y.push(new wall(x, y, distance, direction, this)); break;
					default: break;
				}
			}
		}	
		class collisionEntity extends entity{
			constructor(boxX, boxY, boxHeight, boxWidth){
				super(null, 0, 0, 0, 0, 0, 0, 1, 1);
				this.still = true;
				this.speed = 0;
				this.img = null;
			}
		}

		// offset of 8, hitHeight of 
		class player extends entity{
			constructor(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				super(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height);
				this.movement = [];
				this.controls = {};
				this.mouseControls = {};
			}
			onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};					
				//whenDown = whenDown || ()=>{};
				this.controls[keyCode] = new key(keyCode, ()=>{
					if (type === "x") this.moveX(this.x+reversed*this.speed);
					else if(type === "y") this.moveY(this.y+reversed*this.speed);
					if (!(imageIndex === null)) this.index = imageIndex;
					this.move(keyCode);					
					whenDown();
				}, ()=>{
					this.stop(keyCode);
					whenUp();
				}, 1000/60);				
			}
			move(key){
				var temp = this.movement.indexOf(key);
				if (temp == -1) this.movement.push(key);
			}
			stop(key) {
				var temp = this.movement.indexOf(key);
				if (temp == -1) return false;				
				this.movement.splice(temp, 1);
			}
			moving(){
				return this.movement.length != 0;
			}	
			onCursorMove(label, func){
				this.mouseControls[label] = new cursorMove(func, this);
			}
			onCursorClick(label, button, repetition, whenDown, whenUp){
				this.mouseControls[label] = new cursorClick(button, repetition, whenDown, whenUp, this);
			}
			clean(){
				for (var key in this.controls) {
					this.controls[key].destroy();
				}
				for (var key in this.mouseControls) {
					this.mouseControls[key].destroy();
				}
				this.destroy();
			}
		}
		class cursorMove{
			constructor(func, objectRef) {
				this.mousePos = {
					x: 0,
					y: 0
				};
				this.exe = ()=>{func(this.mousePos, objectRef);};
				document.addEventListener("mousemove", (e)=>{
					this.mousePos.x = e.clientX;
					this.mousePos.y = e.clientY;
					this.exe();
				});
			}
		}
		class cursorClick {
			constructor(button, repetition, whenDown, whenUp, objectRef) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};				
				switch(button) {
					case "left": button = 0; break;
					case "right": button = 2; break;
					default: break;
				}
				//this.exe = func;
				this.button = button;
				this.time = repetition;
				this.clicking = false;
				this.mouse = {
					x: 0,
					y: 0,
				}
				this.ondown = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
					if (!this.clicking) {
						this.clicking = true;
						whenDown(this.mouse, objectRef);
						if (repetition !== 0) this.clicking = setInterval(()=>whenDown(this.mouse, objectRef), repetition);
					}
				};
				this.onmove = (e)=>{
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
				};
				this.onup = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;										
					if (this.clicking) {
						whenUp(this.mouse, objectRef);
						if (repetition !== 0) clearInterval(this.clicking);
						this.clicking = false;
					}
				};
				document.addEventListener("mousedown", this.ondown);
				document.addEventListener("mousemove", this.onmove);				
				document.addEventListener("mouseup", this.onup);
			}
			destroy(){
				document.removeEventListener("mousedown", this.ondown);
				document.removeEventListener("mousemove", this.onmove);				
				document.removeEventListener("mouseup", this.onup);				
				delete this;
				//this = undefined;
			}

		}
		/*class collision{
			constructor(){
				this.allWalls = arguments;
			}
		}*/
		var fps = document.getElementById("FPS");
		function testLoop(func, time){
			setTimeout(()=>{
				var temp = Date.now();
				//fps.innerHTML = Math.round(1000/(temp-time));
				testLoop(func, temp);
			}, 1000/60);
			func();
		}
		function rand(min, max) {
			if (min === max) return max;
			return Math.round(Math.random()*(max-min) + min);
		}
		function rng(min, max, excludeMin, excludeMax) {
			var low = excludeMin-min;
			var high = max-excludeMax;
			var random = Math.round(this.rand(0, low+high+1));
			if (random >= 0 && random <= low) {
				return random+min;
			} else if (random > low && random <= low+high+1) {
				return random-low+excludeMax;
			}
		}
			var canvas = canvasGen();
		class wall {
			constructor(x, y, distance, direction, OBJ){
				this.x = x;
				this.y = y;
				this.distance = distance;
				if (direction === 'x') {
					this.check = (x, y1, y2, onImpact)=>{
						var bounds = [this.x, this.x+this.distance];
						if (!(bounds[0] <= x && x <= bounds[1])) return {y:y2, impact: false};
						if (y1>y2) {
							if (y1 >= this.y && this.y > y2) return {y:this.y, impact:OBJ};
						} else {
							if (y2 >= this.y && this.y > y1) return {y:this.y, impact:OBJ};
						}
						return {y:y2, impact: false};

					};
				} else if (direction === 'y') {
					this.check = (y, x1, x2, onImpact)=>{
						//console.log(y,x1,x2);
						var bounds = [this.y, this.y+this.distance];
						if (!(bounds[0] <= y && y <= bounds[1])) return {x:x2, impact: false};
						if (x1>x2) {
							if (x1 >= this.x && this.x > x2) return {x:this.x, impact:OBJ}; // limit
						}
						else {
							if(x2 >= this.x && this.x > x1) return {x:this.x, impact:OBJ};
						}
						return {x:x2, impact: false};
					};	
				}
			}
		}
		//allCol.push({y: new wall(0,0,canvas.width, "x", "wall"), x: new wall(0,0,canvas.height, "y", "wall")});
		//allCol.push({y: new wall(0,canvas.height,canvas.width, "x", "wall"), x: new wall(canvas.width,0,canvas.height, "y", "wall")});		
		async function start(){
			document.addEventListener("contextmenu", (e)=>e.preventDefault());
			var art = await loadImages(["test.png", "testBack.png", "enemy.png", "enemyBack.png", "target.png", "newEnemy.png", "orb.png", "download2.png"]);
			//var player = new entity([art["test.png"], art["testBack.png"]]);
			//onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp)
			var mainPlayer = new player([art["test.png"], art["testBack.png"]], 100, 100, 41, 58, 10, 8, 48,48);
			var box = new collisionEntity(0,0, 703, 703);
			box.addCollision(0,0,canvas.width, "x");
			box.addCollision(0,0,canvas.height, "y");
			box.addCollision(0,canvas.height,canvas.width, "x");
			box.addCollision(canvas.width,0,canvas.height, "y");
			box.prop["type"] = "wall";
			//player.draw(canvas.ctx);
			/*var cur = new cursorMove((mouse)=>{
				if (mainPlayer.moving()) return;
				if (mouse.y-32 < mainPlayer.y) mainPlayer.index = 1;
				else mainPlayer.index = 0;
			});	*/
			mainPlayer.speed = 5;			
			//mainPlayer.onmove("KeyS", false, "y", 0, false, ()=>{cur.exe();});
			//mainPlayer.onmove("KeyW", true, "y", 1, false, ()=>{cur.exe();});
			mainPlayer.onCursorMove("face", (mouse, playerData)=>{
				if (playerData.moving()) return;
				if (mouse.y-32 < mainPlayer.y) playerData.index = 1;
				else playerData.index = 0;				
			});
			mainPlayer.onmove("KeyS", 1, "y", 0, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});
			mainPlayer.onmove("KeyW", -1, "y", 1, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});			
			mainPlayer.onmove("KeyA", -1, "x", null, false, false);
			mainPlayer.onmove("KeyD", 1, "x", null, false, false);	
			var update = ()=>{
				canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
				var temp = Object.getOwnPropertySymbols(allEntities);
				fps.innerHTML = temp.length;				
				//canvas.ctx.drawImage(art["download2.png"], 0, 0);
				for (var i = 0; i < temp.length; i++) allEntities[temp[i]].draw(canvas.ctx);
				//console.log("LOL");
			}	
			mainPlayer.onCursorClick("leftClick", "left", 1000/60, (mouse, playerData)=>{
				var temp = new entity([art["orb.png"]], playerData.x+32-4, playerData.y+32-4, 8, 8, 4, 4);
				//Offset height - offset
				temp.oncollision((c, o)=>{if(o.prop["type"] == "wall") c.destroy();});
				temp.moveTo(mouse.x-4-canvas.x, mouse.y-4-canvas.y, ()=>{});
				temp.speed = 1;
			}, false);
			//var orb = new entity([art["orb.png"]], 100, 100);
			//orb.speed = 5;
			//orb.moveTo(500, 500);
			testLoop(()=>{requestAnimationFrame(update);}, 0);
			//new collision([[0,0], [0, canvas.height]], [[0, canvas.height],[canvas.width, canvas.height]], [[canvas.width, canvas.height],[canvas.width, 0]], [[canvas.width, 0],[0,0]]);
			//for (var i = 0; i < 2000; i++) 
			//enemies.push(new entity([art["enemy.png"], art["enemyBack"]], rand(0, window.innerHeight-20), rand(0, window.innerHeight-20)));
			/*setInterval(()=>{
				for (var i = 0; i < enemies.length; i++) {
					var enemy = enemies[i];
					if (enemy.x < mainPlayer.x) enemy.x+=rand(10,10);
					if (enemy.y < mainPlayer.y) enemy.y+=rand(10,10);
					if (enemy.y > mainPlayer.y) enemy.y-=rand(10,10);
					if (enemy.x > mainPlayer.x) enemy.x-=rand(10,10);					
				}
			}, 1000/60);*/
			//setInterval(()=>{requestAnimationFrame(update);}, 1000/60);
		}
		start();
		//setTimeout(start, 10);
		function collision(x1, y1, x2, y2){
			var col = [[[0,0], [0, canvas.height]], [[0, canvas.height],[canvas.width, canvas.height]], [[canvas.width, canvas.height],[canvas.width, 0]], [[0, 0],[canvas.width,0]]];
			for (var i = 0; i < col.length; i++) {
				var temp = limiter(x1, y1, x2, y2, col[i]);
				console.log("I: ", i, " | ", JSON.stringify(temp), " | ", x1, " : ", y1);
				x2 = temp.x;
				y2 = temp.y;
			}
			return {x:x2, y:y2};
		}

		function limiter(x1, y1, x2, y2, temp){
			//var temp = [[0,0], [10, 0]];
			if (temp[0][0] === temp[1][0]) {
				if (!(y1 > temp[0][1] && y2 < temp[1][1])) return {x:x2, y:y2};
				if ((x1 > temp[0][0] && temp[0][0] > x2) || (x1 < temp[0][0] && temp[0][0] < x2)) {
					return {x:temp[0][0], y:y2};
				}
				return {x:x2, y:y2};
			} else if (temp[0][1] === temp[1][1]) {
				console.log(x1, y1, x2, y2);
				if (!(x1 > temp[0][0] && x2 < temp[1][0])) return {x:x2, y:y2};
				if ((y1 >= temp[0][1] && temp[0][1] >= y2) || (y1 < temp[0][1] && temp[0][1] < y2)) {
					console.log("DONE");
					return {x:x2, y:temp[0][1]};
				}
				return {x:x2, y:y2};
			}
			//if (x < temp[0][0] && x > temp[1][0]);
			//if (y < temp[0][1] && y < temp[1][1]);
			//return {x:x, y:y};
		}
	</script>
</body>
</html>