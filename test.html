<!DOCTYPE HTML>
<html>
<body style="overflow: hidden; margin: none; border: none; outline: none">
	<style>
	canvas{
		outline: 5px solid black;
	}
	html{
		cursor: url("cursor.png") 8 8, pointer;
	}
	div{
		position: fixed;
		top: 10px;
		font-size: 40px;
		left: 10px;
		user-select: none;
		pointer-events: none;
	}
</style>
<div id="FPS">0</div>
	<script>
		function canvasGen(){
			var temp = document.createElement("CANVAS");
			temp.id = "screen";
			temp.width = window.innerHeight-20;
			temp.height = window.innerHeight-20;
			temp.style=`position: fixed; top: 10px; left: ${(window.innerHeight-20)/2}px;`;
			document.body.appendChild(temp);
			return {
				width: window.innerHeight-20,
				height: window.innerHeight-20,
				x: (window.innerHeight-20)/2,
				y: 10,
				ctx: temp.getContext("2d"),
			}
		}
		function createEntity(){

		}
	</script>
	<script>
		async function loadImages(arrImages){
			var temp = {};
			for (var i = 0; i < arrImages.length; i++) {
				var other = new Image();
				other.src = arrImages[i];
				await new Promise((resolve)=>{
					other.onload = ()=>{
						resolve();
					}
				});
				temp[arrImages[i]] = other;
			}
			return temp;
		}
		var allEntities = {};
		var allCol = [];
		class key{
			constructor(keyCode, whenDown, whenUp, speed){
				this.mainKey = keyCode;
				this.keyDown = false;
				this.whenDown = (e)=>{
					if (e.code != this.mainKey) return;
					if (!this.keyDown) {
						this.keyDown = true;
						whenDown();
						if (speed != 0) this.keyDown = setInterval(whenDown, speed);
					}
				};
				this.whenUp = (e)=>{
					if (e.code != this.mainKey) return;					
					if (this.keyDown) {
						whenUp();
						if (speed != 0) clearInterval(this.keyDown);
						this.keyDown = false;
					}
				};
				document.addEventListener("keydown", this.whenDown);
				document.addEventListener("keyup", this.whenUp);
			}
			destroy(){
				document.removeEventListener("keydown", this.whenDown);
				document.removeEventListener("keyup", this.whenUp);
				delete this;
			}
		}
		function distance(x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
		}		
		function ERR(actual, calc){
			if (Math.round(actual) == Math.round(calc)) console.log("PERFECT");
			else console.log(Math.round((actual-calc)/calc*100) + "%");
		}
		class entity {
			constructor(image, x, y, hitHeight, hitWidth, offset, width, height){
				this.img = image;
				this.x = x || 0;
				this.y = y || 0;
				this.hitOffset = offset || 0;
				this.height = height || image[0].height;
				this.width = width || image[0].width;
				this.hitHeight = this.height;
				this.hitWidth = this.width;				
				this.index = 0;
				this.speed = 1;
				this.moveToLoop = false;
				this.id = Symbol();
				allEntities[this.id] = this;				
			}
			draw(ctx){
				ctx.drawImage(this.img[this.index], this.x, this.y);
			}
			tp(x,y){
				this.x = x;
				this.y = y;
			}
			moveTo(x, y, reach, collision){
				//One pixel every frame
				this.stopMoving();
				var rise = y-this.y, run = x-this.x, dist = distance(x,y,this.x,this.y), xPos = 1, yPos = 1;
				if (rise < 0) yPos = -1;
				if (run < 0) xPos = -1;
				var timeStart = Date.now();
				this.moveToLoop = true;
				this.moveToLoop = setInterval(()=>{
					var tempY = this.y + rise/dist*this.speed;
					var tempX = this.x + run/dist*this.speed;
					//console.log(dist, run/dist*this.speed, run/dist*this.speed, (Date.now()-timeStart), rise, run);
					if ((tempX-x)*xPos >= 0 && (tempY-y)*yPos >= 0){ // -x means that tempY is negative 
						ERR((Date.now()-timeStart), 1000/60*dist/this.speed);
						this.y = y;
						this.x = x;
						this.stopMoving();
					} else {
						this.y = tempY;
						this.x = tempX;
					}
				}, 1000/60);
			}
			stopMoving(){
				// Not currently rounding!!!!
				if (this.moveToLoop) {
					clearInterval(this.moveToLoop);
					this.moveToLoop = false;
				}
			}
			destroy(){
				delete this;
			}
		}		
		class player extends entity{
			constructor(image, x, y, hitHeight, hitWidth, offset, width, height){
				super(image, x, y, hitHeight, hitWidth, offset, width, height);
				this.movement = [];
				this.controls = {};
				this.mouseControls = {};
			}
			onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};					
				//whenDown = whenDown || ()=>{};
				this.controls[keyCode] = new key(keyCode, ()=>{
					if (type === "x") this.moveX(reversed);
					else if(type === "y") this.moveY(reversed);
					if (!(imageIndex === null)) this.index = imageIndex;
					this.move(keyCode);					
					whenDown();
				}, ()=>{
					this.stop(keyCode);
					whenUp();
				}, 1000/60);				
			}
			move(key){
				var temp = this.movement.indexOf(key);
				if (temp == -1) this.movement.push(key);
			}
			stop(key) {
				var temp = this.movement.indexOf(key);
				if (temp == -1) return false;				
				this.movement.splice(temp, 1);
			}
			moving(){
				return this.movement.length != 0;
			}
			moveX(reverse){
				if (reverse) this.x = checkAllX(this.y+8, this.x+10, this.x-this.speed+10)-10;
				else this.x = checkAllX(this.y+8, this.x, this.x+this.speed+51)-51;				
			}
			moveY(reverse){
				if (reverse) this.y = checkAllY(this.x+10, this.y+8, this.y-this.speed+8)-8;
				else this.y = checkAllY(this.x+10, this.y, this.y+this.speed+64)-64;
			}
			onCursorMove(label, func){
				this.mouseControls[label] = new cursorMove(func, this);
			}
			onCursorClick(label, button, repetition, whenDown, whenUp){
				this.mouseControls[label] = new cursorClick(button, repetition, whenDown, whenUp, this);
			}
			clean(){
				for (var key in this.controls) {
					this.controls[key].destroy();
				}
				delete allEntities[this.id];
				this.destroy();
			}
		}
		class cursorMove{
			constructor(func, objectRef) {
				this.mousePos = {
					x: 0,
					y: 0
				};
				this.exe = ()=>{func(this.mousePos, objectRef);};
				document.addEventListener("mousemove", (e)=>{
					this.mousePos.x = e.clientX;
					this.mousePos.y = e.clientY;
					this.exe();
				});
			}
		}
		class cursorClick {
			constructor(button, repetition, whenDown, whenUp, objectRef) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};				
				switch(button) {
					case "left": button = 0; break;
					case "right": button = 2; break;
					default: break;
				}
				//this.exe = func;
				this.button = button;
				this.time = repetition;
				this.clicking = false;
				this.mouse = {
					x: 0,
					y: 0,
				}
				this.ondown = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
					if (!this.clicking) {
						this.clicking = true;
						whenDown(this.mouse, objectRef);
						if (repetition !== 0) this.clicking = setInterval(()=>whenDown(this.mouse, objectRef), repetition);
					}
				};
				this.onmove = (e)=>{
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
				};
				this.onup = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;										
					if (this.clicking) {
						whenUp(this.mouse, objectRef);
						if (repetition !== 0) clearInterval(this.clicking);
						this.clicking = false;
					}
				};
				document.addEventListener("mousedown", this.ondown);
				document.addEventListener("mousemove", this.onmove);				
				document.addEventListener("mouseup", this.onup);
			}
			destroy(){
				document.removeEventListener("mousedown", this.ondown);
				document.removeEventListener("mousemove", this.onmove);				
				document.removeEventListener("mouseup", this.onup);				
				delete this;
				//this = undefined;
			}

		}
		/*class collision{
			constructor(){
				this.allWalls = arguments;
			}
		}*/
		var fps = document.getElementById("FPS");
		function testLoop(func, time){
			setTimeout(()=>{
				var temp = Date.now();
				//fps.innerHTML = Math.round(1000/(temp-time));
				testLoop(func, temp);
			}, 1000/60);
			func();
		}
		function rand(min, max) {
			if (min === max) return max;
			return Math.round(Math.random()*(max-min) + min);
		}
		function rng(min, max, excludeMin, excludeMax) {
			var low = excludeMin-min;
			var high = max-excludeMax;
			var random = Math.round(this.rand(0, low+high+1));
			if (random >= 0 && random <= low) {
				return random+min;
			} else if (random > low && random <= low+high+1) {
				return random-low+excludeMax;
			}
		}
			var canvas = canvasGen();
			class wall {
				constructor(x, y, distance, positive, direction){
					this.x = x;
					this.y = y;
					this.distance = distance;
					this.positive = positive;
					if (direction === 'x') {
						this.check = (x, y1, y2)=>{
							var bounds = [this.x, this.x+this.distance];
							if (!(bounds[0] <= x && x <= bounds[1])) return {y:y2, impact: false};
							if (this.positive) {
								if (y2 > this.y && y1 <= this.y) return {y:this.y, impact:true}; // limit
							}
							else {
								if(y2 < this.y && y1 >= this.y) return {y:this.y, impact:true};
							}
							return {y:y2, impact: false};

						};
					} else if (direction === 'y') {
						this.check = (y, x1, x2)=>{
							var bounds = [this.y, this.y+this.distance];
							if (!(bounds[0] <= y && y <= bounds[1])) return {x:x2, impact: false};
							if (this.positive) {
								if (x2 > this.x && x1 <= this.x) return {x:this.x, impact:true}; // limit
							}
							else {
								if(x2 < this.x && x1 >= this.x) return {x:this.x, impact:true};
							}
							return {x:x2, impact: false};
						};
					}
				}
			}
		allCol.push({y: new wall(0,0,canvas.width, false, "x"), x: new wall(0,0,canvas.height, false, "y")});
		allCol.push({y: new wall(0,canvas.height,canvas.width, true, "x"), x: new wall(canvas.width,0,canvas.height, true, "y")});		
		function checkAllY(x, y1, y2){
			for (var i = 0; i < allCol.length; i++) {
				y2 = allCol[i].y.check(x, y1, y2).y;
			}
			return y2;
		}
		function checkAllX(y, x1, x2){
			for (var i = 0; i < allCol.length; i++) {
				x2 = allCol[i].x.check(y, x1, x2).x;
			}
			return x2;
		}		
		async function start(){
			document.addEventListener("contextmenu", (e)=>e.preventDefault());
			var art = await loadImages(["test.png", "testBack.png", "enemy.png", "enemyBack.png", "target.png", "newEnemy.png", "orb.png"]);
			//var player = new entity([art["test.png"], art["testBack.png"]]);
			//onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp)
			var mainPlayer = new player([art["test.png"], art["testBack.png"]], 100, 100);
			//player.draw(canvas.ctx);
			/*var cur = new cursorMove((mouse)=>{
				if (mainPlayer.moving()) return;
				if (mouse.y-32 < mainPlayer.y) mainPlayer.index = 1;
				else mainPlayer.index = 0;
			});	*/
			mainPlayer.speed = 5;			
			//mainPlayer.onmove("KeyS", false, "y", 0, false, ()=>{cur.exe();});
			//mainPlayer.onmove("KeyW", true, "y", 1, false, ()=>{cur.exe();});
			mainPlayer.onCursorMove("face", (mouse, playerData)=>{
				if (playerData.moving()) return;
				if (mouse.y-32 < mainPlayer.y) playerData.index = 1;
				else playerData.index = 0;				
			});
			mainPlayer.onmove("KeyS", false, "y", 0, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});
			mainPlayer.onmove("KeyW", true, "y", 1, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});			
			mainPlayer.onmove("KeyA", true, "x", null, false, false);
			mainPlayer.onmove("KeyD", false, "x", null, false, false);	
			var update = ()=>{
				canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
				fps.innerHTML = mainPlayer.x + " | " + mainPlayer.y;
				var temp = Object.getOwnPropertySymbols(allEntities);
				for (var i = 0; i < temp.length; i++) allEntities[temp[i]].draw(canvas.ctx);
				//console.log("LOL");
			}	
			mainPlayer.onCursorClick("leftClick", "left", 0, (mouse, playerData)=>{
				var temp = new entity([art["orb.png"]], playerData.x+0, playerData.y+0);
				temp.moveTo(mouse.x-8-canvas.x, mouse.y-8-canvas.y);
				temp.speed = 100;
			}, false);
			//var orb = new entity([art["orb.png"]], 100, 100);
			//orb.speed = 5;
			//orb.moveTo(500, 500);
			testLoop(()=>{requestAnimationFrame(update);}, 0);
			//new collision([[0,0], [0, canvas.height]], [[0, canvas.height],[canvas.width, canvas.height]], [[canvas.width, canvas.height],[canvas.width, 0]], [[canvas.width, 0],[0,0]]);
			//for (var i = 0; i < 2000; i++) 
			//enemies.push(new entity([art["enemy.png"], art["enemyBack"]], rand(0, window.innerHeight-20), rand(0, window.innerHeight-20)));
			/*setInterval(()=>{
				for (var i = 0; i < enemies.length; i++) {
					var enemy = enemies[i];
					if (enemy.x < mainPlayer.x) enemy.x+=rand(10,10);
					if (enemy.y < mainPlayer.y) enemy.y+=rand(10,10);
					if (enemy.y > mainPlayer.y) enemy.y-=rand(10,10);
					if (enemy.x > mainPlayer.x) enemy.x-=rand(10,10);					
				}
			}, 1000/60);*/
			//setInterval(()=>{requestAnimationFrame(update);}, 1000/60);
		}
		start();
		//setTimeout(start, 10);
		function collision(x1, y1, x2, y2){
			var col = [[[0,0], [0, canvas.height]], [[0, canvas.height],[canvas.width, canvas.height]], [[canvas.width, canvas.height],[canvas.width, 0]], [[0, 0],[canvas.width,0]]];
			for (var i = 0; i < col.length; i++) {
				var temp = limiter(x1, y1, x2, y2, col[i]);
				console.log("I: ", i, " | ", JSON.stringify(temp), " | ", x1, " : ", y1);
				x2 = temp.x;
				y2 = temp.y;
			}
			return {x:x2, y:y2};
		}

		function limiter(x1, y1, x2, y2, temp){
			//var temp = [[0,0], [10, 0]];
			if (temp[0][0] === temp[1][0]) {
				if (!(y1 > temp[0][1] && y2 < temp[1][1])) return {x:x2, y:y2};
				if ((x1 > temp[0][0] && temp[0][0] > x2) || (x1 < temp[0][0] && temp[0][0] < x2)) {
					return {x:temp[0][0], y:y2};
				}
				return {x:x2, y:y2};
			} else if (temp[0][1] === temp[1][1]) {
				console.log(x1, y1, x2, y2);
				if (!(x1 > temp[0][0] && x2 < temp[1][0])) return {x:x2, y:y2};
				if ((y1 >= temp[0][1] && temp[0][1] >= y2) || (y1 < temp[0][1] && temp[0][1] < y2)) {
					console.log("DONE");
					return {x:x2, y:temp[0][1]};
				}
				return {x:x2, y:y2};
			}
			//if (x < temp[0][0] && x > temp[1][0]);
			//if (y < temp[0][1] && y < temp[1][1]);
			//return {x:x, y:y};
		}
	</script>
</body>
</html>