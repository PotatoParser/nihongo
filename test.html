<!DOCTYPE HTML>
<html draggable="false">
<body style="overflow: hidden; margin: none; border: none; outline: none">
	<style>
	canvas{
		outline: 5px solid black;
		user-select: none;
	}
	html{
		cursor: url("cursor.png") 8 8, pointer;
		background-color: #111111;
	}
	/*div{
		position: fixed;
		top: 10px;
		font-size: 40px;
		left: 10px;
		user-select: none;
		pointer-events: none;
		color: white;
	}*/
	.slot{
		/*outline: 1px dotted white;*/
		border-radius: 5px;
		border: 2px solid white;
		position: absolute;
	}
	.inventory{
		/*outline: 5px dashed white;*/
		border-radius: 10px;
		border: 4px solid white;
		position:fixed;
	}
	.slot:hover{
		background-color: rgba(255,255,255,0.3);
	}
	div{
		user-select: none;
	}
	img{
		user-select: none;
	}
	.item{
		pointer-events: none;
		user-select: none;
	}
</style>
<div id="FPS">0</div>
	<script>
		// (C) Wilson Nguyen
		// Faster method if you create a queue mechanic
		// Use webworkers to speed up processing speed
		function canvasGen(){
			var temp = document.createElement("CANVAS");
			temp.id = "screen";
			temp.width = window.innerHeight-20;
			temp.height = window.innerHeight-20;
			temp.style=`position: fixed; top: 10px; left: ${(window.innerHeight-20)/2}px;`;
			document.body.appendChild(temp);
			return {
				width: window.innerHeight-20,
				height: window.innerHeight-20,
				x: (window.innerHeight-20)/2,
				y: 10,
				ctx: temp.getContext("2d"),
			}
		}
		function createEntity(){

		}
	</script>
	<script>
		async function loadImages(arrImages){
			var temp = {};
			for (var i = 0; i < arrImages.length; i++) {
				var other = new Image();
				other.src = arrImages[i];
				other.draggable = false;
				await new Promise((resolve)=>{
					other.onload = ()=>{
						resolve();
					}
				});
				temp[arrImages[i]] = other;
			}
			return temp;
		}
		var ENTITY = {};
		var COLLISION = {};
		var SCALE = Math.floor(window.innerHeight/15);
		class wall {
			constructor(x, y, distance, direction, OBJ){
				this.x = x;
				this.y = y;
				this.distance = distance;
				if (direction === 'x') {
					this.check = (x, dist, y1, y2, onImpact)=>{
						var bounds = [this.x, this.x+this.distance];
						if (!((bounds[0] < x || bounds[0] < x+dist) && (x < bounds[1] || x+dist < bounds[1]))) return {y:y2, impact: false, old: y2};
						if (y1>y2) {
							if (y1 >= this.y && this.y > y2) return {y:this.y, impact:OBJ, old:y2};
						} else {
							if (y2 >= this.y && this.y > y1) return {y:this.y, impact:OBJ, old:y2};
						}
						if (isNaN(y2)) {
							console.log(x, dist, y1, y2, "TWO");
							debugger;
						}
						return {y:y2, impact: false, old:y2};

					};
				} else if (direction === 'y') {
					this.check = (y, dist, x1, x2, onImpact)=>{
						//console.log(y,x1,x2);
						var bounds = [this.y, this.y+this.distance];
						if (!((bounds[0] < y || bounds[0] <y+dist) && (y < bounds[1] || y+dist < bounds[0]))) return {x:x2, impact: false, old:x2};
						if (x1>x2) {
							if (x1 >= this.x && this.x > x2) return {x:this.x, impact:OBJ, old:x2}; // limit
						}
						else {
							if(x2 >= this.x && this.x > x1) return {x:this.x, impact:OBJ, old:x2};
						}

						return {x:x2, impact: false, old:x2};
					};	
				}
			}
		}			
		class layer {
			constructor(x, y, width, height, image, index){
				this.element = document.createElement("CANVAS");
				this.img = image || null;
				this.x = x || 0;
				this.y = y || 0;
				this.width = width || 100;
				this.height = height || 100;
				//this.show();				
				this.ctx = this.element.getContext("2d");
				this.index = index || 0;
				this.setPosition();
				this.setDimension();
				this.reload();				
			}
			reload(){
				if (this.img != null) {
					this.ctx.drawImage(this.img, 0, 0, this.width, this.height);
				}
			}
			setPosition(x, y){
				this.element.style.position = "fixed";
				this.element.style.left = `${x || this.x}px`;
				this.element.style.top = `${y || this.y}px`;
				this.element.style["z-index"] = this.index;
			}
			setDimension(width, height) {
				this.element.width = width || this.width;
				this.element.height = height || this.height;
			}
			hide(){
				this.element.remove();				
			}
			show(){
				console.log("RUN");
				document.body.appendChild(this.element);
			}
		}
		class key{
			constructor(keyCode, whenDown, whenUp, speed){
				this.mainKey = keyCode;
				this.keyDown = false;
				this.whenDown = (e)=>{
					if (e.code != this.mainKey) return;
					if (!this.keyDown) {
						this.keyDown = true;
						whenDown();
						if (speed != 0) this.keyDown = setInterval(whenDown, speed);
					}
				};
				this.whenUp = (e)=>{
					if (e.code != this.mainKey) return;					
					if (this.keyDown) {
						whenUp();
						if (speed != 0) clearInterval(this.keyDown);
						this.keyDown = false;
					}
				};
				document.addEventListener("keydown", this.whenDown);
				document.addEventListener("keyup", this.whenUp);
			}
			destroy(){
				if (this.keyDown) clearInterval(this.keyDown);
				document.removeEventListener("keydown", this.whenDown);
				document.removeEventListener("keyup", this.whenUp);
				delete this;
			}
		}
		function distance(x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
		}		
		function ERR(actual, calc){
			if (Math.round(actual) == Math.round(calc)) console.log("PERFECT");
			else console.log(Math.round((actual-calc)/calc*100) + "%");
		}
		class entity{
			constructor(entity, collision, image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				this.img = image;
				this.x = x || 0;
				this.y = y || 0;
				this.height = height || image[0].height;
				this.width = width || image[0].width;			
				this.index = 0;
				this.speed = 1;
				this.moveToLoop = false;
				this.id = Symbol();
				this.prop = {};
				this.hit = {
					offX: offsetX || 0,
					offY: offsetY || 0,
					offWidth: (hitWidth || this.width),
					offHeight: (hitHeight || this.height),
				}
				this.collisionEvent = [];
				this.colArea = {
					x: [],
					y: []
				}
				if (entity) this.ENTITY = entity;
				if (collision) this.COLLISION = collision;
				this.still = false;
				if (entity) this.ENTITY[this.id] = this;
				this.alg = [];	
				this.movehit = false;
			}
			draw(ctx){
				if (!this.still) ctx.drawImage(this.img[this.index], this.x-this.hit.offX, this.y-this.hit.offY, this.width, this.height);
			}
			tp(x,y){
				if (x) this.x = x;
				if (y) this.y = y;
			}
			moveX(newX){
				if (newX < this.x) this.x = this.checkAllX(this.y, this.hit.offHeight, this.x, newX);
				else this.x = this.checkAllX(this.y, this.hit.offHeight, this.x, newX+this.hit.offWidth)-this.hit.offWidth;	
				if (this.movehit) this.hitbox();			
			}			
			moveY(newY){
				if (isNaN(newY)) {
					console.log(newY, "ZERO1");
					debugger;
				}	
				if (newY < this.y) this.y = this.checkAllY(this.x, this.hit.offWidth, this.y, newY);
				else this.y = this.checkAllY(this.x, this.hit.offWidth, this.y, newY+this.hit.offHeight)-this.hit.offHeight;
				if (this.movehit) this.hitbox();			
			}			
			moveTo(x, y, reach){
				//One pixel every frame
				this.stopMoving();
				var rise = y-this.y, run = x-this.x, dist = distance(x,y,this.x,this.y), xPos = 1, yPos = 1;
				if (dist == 0) return;
				if (rise < 0) yPos = -1;
				if (run < 0) xPos = -1;
				this.moveToLoop = true;
				this.moveToLoop = setInterval(()=>{
					var tempY = this.y + rise/dist*this.speed;
					var tempX = this.x + run/dist*this.speed;
					if ((tempX-x)*xPos >= 0 && (tempY-y)*yPos >= 0){ // -x means that tempY is negative 
						if (!reach) {
							this.moveY(y);
							this.moveX(x);
							this.stopMoving();	
							return;
						} else reach(this,x,y);
					}
					if (isNaN(tempY)) {
						console.log(this.y, rise, dist, this.speed, tempY, "ZERO2");
						debugger;
					}						
					this.moveY(tempY);
					this.moveX(tempX);
				}, 1000/60);
			}					
			stopMoving(){
				// Not currently rounding!!!!
				if (this.moveToLoop) {
					clearInterval(this.moveToLoop);
					this.moveToLoop = false;
				}
			}
			oncollision(func){
				this.collisionEvent.push(func);
			}
			checkAllY(x, dist, y1, y2){
				var temp2 = y2+0;
				if (isNaN(temp2)) {
					console.log(x, dist, y1, y2, "ZERO");
					debugger;
				}	
				var allEnt = Object.getOwnPropertySymbols(this.COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;		
					for (var i = 0; i < this.ENTITY[allEnt[b]].colArea.y.length; i++) {
						if (isNaN(temp2)) {
							console.log(x, dist, y1, y2, "ONE");
							debugger;
						}								
						var temp = this.ENTITY[allEnt[b]].colArea.y[i].check(x, dist, y1, temp2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								//console.log(x, y1, y2, temp);
								var atImpact = this.collisionEvent[a](this, temp.impact, temp);
								if (atImpact) {
									console.log("SOMETHING");
									return atImpact;
								}
							}
						}
						temp2 = temp.y;
						if (isNaN(temp2)) {
							console.log(x, dist, y1, y2, temp, "THREE");
							debugger;
						}						
					}
				}
				return temp2;
			}
			checkAllX(y, dist, x1, x2){
				var allEnt = Object.getOwnPropertySymbols(this.COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;	
					for (var i = 0; i < this.ENTITY[allEnt[b]].colArea.x.length; i++) {
						var temp = this.ENTITY[allEnt[b]].colArea.x[i].check(y, dist, x1, x2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								//console.log(temp);
								var atImpact = this.collisionEvent[a](this, temp.impact, temp);
								if (atImpact) {
									console.log("SOMETHING");
									return atImpact;
								}
							}
						}		
						x2 = temp.x;
					}
				}
				return x2;
			}		
			destroy(){
				if (this.moveToLoop) clearInterval(this.moveToLoop);
				delete this.ENTITY[this.id];
				delete this.COLLISION[this.id];				
				delete this;
			}
			addCollision(x, y, distance, direction){
				this.COLLISION[this.id] = this;
				var exists = false;
				switch(direction) {
					case "y": 
						for (var i = 0; i < this.colArea.x.length; i++) 
							if (this.colArea.x[i].x == x && this.colArea.x[i].y == y && this.colArea.x[i].distance == distance) 
								exists = true;
						this.colArea.x.push(new wall(x, y, distance, direction, this)); 
						break;
					case "x": 
						for (var i = 0; i < this.colArea.y.length; i++) 
							if (this.colArea.y[i].x == x && this.colArea.y[i].y == y && this.colArea.y[i].distance == distance) 
								exists = true;
						if (!exists) this.colArea.y.push(new wall(x, y, distance, direction, this)); 
						break;
					default: break;
				}
			}
			hitbox(xOffset, yOffset, widthT, heightT){
				if (xOffset === true) this.movehit = true;
				this.colArea.x = [];
				this.colArea.y = [];
				//var tempX = this.hit.offX || (this.x+(xOffset || 0));
				//var tempY = this.hit.offY || (this.y+(yOffset || 0));
				var tempX = (typeof xOffset == 'number') ? this.x+xOffset : this.x;
				var tempY = (typeof yOffset == 'number') ? this.y+yOffset : this.y;
				//var tempY = this.hit.offY || (this.y+(yOffset || 0));				
				var tempWidth = (typeof widthT == 'number') ? widthT : this.hit.offWidth;
				var tempHeight = (typeof heightT == 'number') ? heightT : this.hit.offHeight;
				//console.log(tempX, tempY, tempWidth, tempHeight);
				this.addCollision(tempX, tempY, tempWidth, "x");
				this.addCollision(tempX, tempY, tempHeight, "y");
				this.addCollision(tempX, tempY+tempHeight, tempWidth, "x");
				this.addCollision(tempX+tempWidth, tempY, tempHeight, "y");
			}
			modifiedHitbox(){
				this.colArea.x = [];
				this.colArea.y = [];
				//var tempX = this.hit.offX || (this.x+(xOffset || 0));
				//var tempY = this.hit.offY || (this.y+(yOffset || 0));
				var tempX = this.x+(xOffset || this.hit.offX);
				var tempY = this.y+(yOffset || this.hit.offY);
				//var tempY = this.hit.offY || (this.y+(yOffset || 0));				
				var tempWidth =  this.hit.offWidth;
				var tempHeight = this.hit.offHeight;
				console.log(tempX, tempY, tempWidth, tempHeight);
				this.addCollision(tempX, tempY, tempWidth, "x");
				this.addCollision(tempX, tempY, tempHeight, "y");
				this.addCollision(tempX, tempY+tempHeight, tempWidth, "x");
				this.addCollision(tempX+tempWidth, tempY, tempHeight, "y");
			}
			addAlgorithm(newAlg){
				this.alg.push(newAlg);
			}
			algorithm(){
				for (var i = 0; i < this.alg.length; i++) {
					this.alg[i](this);
				}
			}
		}	
		class collisionEntity extends entity{
			constructor(entity, collision, boxX, boxY, boxHeight, boxWidth){
				super(entity, collision, null, 0, 0, 0, 0, 0, 0, 1, 1);
				this.still = true;
				this.speed = 0;
				this.img = null;
			}
		}

		// offset of 8, hitHeight of 
		class player extends entity{
			constructor(entity, collision, image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				super(false, false, image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height);
				this.movement = [];
				this.controls = {};
				this.mouseControls = {};
				this.entity = ENTITY;
				this.collision = COLLISION;
				this.prop.type = "player";
			}
			onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};					
				//whenDown = whenDown || ()=>{};
				this.controls[keyCode] = new key(keyCode, ()=>{
					if (type === "x") this.moveX(this.x+reversed*this.speed);
					else if(type === "y") this.moveY(this.y+reversed*this.speed);
					if (!(imageIndex === null)) this.index = imageIndex;
					this.move(keyCode);					
					whenDown();
				}, ()=>{
					this.stop(keyCode);
					whenUp();
				}, 1000/60);				
			}
			move(key){
				var temp = this.movement.indexOf(key);
				if (temp == -1) this.movement.push(key);
			}
			stop(key) {
				var temp = this.movement.indexOf(key);
				if (temp == -1) return false;				
				this.movement.splice(temp, 1);
			}
			moving(){
				return this.movement.length != 0;
			}	
			onCursorMove(label, func){
				this.mouseControls[label] = new cursorMove(func, this);
			}
			onCursorClick(label, button, repetition, whenDown, whenUp){
				this.mouseControls[label] = new cursorClick(button, repetition, whenDown, whenUp, this);
			}
			clean(){
				for (var key in this.controls) {
					this.controls[key].destroy();
				}
				for (var key in this.mouseControls) {
					this.mouseControls[key].destroy();
				}
				this.destroy();
			}
			checkAllY(x, dist, y1, y2){
				var allEnt = Object.getOwnPropertySymbols(COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;		
					for (var i = 0; i < ENTITY[allEnt[b]].colArea.y.length; i++) {
						var temp = ENTITY[allEnt[b]].colArea.y[i].check(x, dist, y1, y2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								//console.log(x, y1, y2, temp);
								var atImpact = this.collisionEvent[a](this, temp.impact, temp);
								if (atImpact) return atImpact;
							}
						}
						y2 = temp.y;
					}
				}
				return y2;
			}
			checkAllX(y, dist, x1, x2){
				var allEnt = Object.getOwnPropertySymbols(COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;	
					for (var i = 0; i < ENTITY[allEnt[b]].colArea.x.length; i++) {
						var temp = ENTITY[allEnt[b]].colArea.x[i].check(y, dist, x1, x2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								//console.log("temp");
								var atImpact = this.collisionEvent[a](this, temp.impact, temp);
								if (atImpact) return atImpact;
							}
						}		
						x2 = temp.x;
					}
				}
				return x2;
			}		
			destroy(){
				if (this.moveToLoop) clearInterval(this.moveToLoop);
				delete ENTITY[this.id];
				delete COLLISION[this.id];				
				delete this;
			}
			addCollision(x, y, distance, direction){
				COLLISION[this.id] = this;
				var exists = false;
				switch(direction) {
					case "y": 
						for (var i = 0; i < this.colArea.x.length; i++) 
							if (this.colArea.x[i].x == x && this.colArea.x[i].y == y && this.colArea.x[i].distance == distance) 
								exists = true;
						this.colArea.x.push(new wall(x, y, distance, direction, this)); 
						break;
					case "x": 
						for (var i = 0; i < this.colArea.y.length; i++) 
							if (this.colArea.y[i].x == x && this.colArea.y[i].y == y && this.colArea.y[i].distance == distance) 
								exists = true;
						if (!exists) this.colArea.y.push(new wall(x, y, distance, direction, this)); 
						break;
					default: break;
				}
			}
		}
		class cursorMove{
			constructor(func, objectRef) {
				this.mousePos = {
					x: 0,
					y: 0
				};
				this.exe = ()=>{func(this.mousePos, objectRef);};
				document.addEventListener("mousemove", (e)=>{
					this.mousePos.x = e.clientX;
					this.mousePos.y = e.clientY;
					this.exe();
				});
			}
		}
		class cursor {
			constructor(whenDown, whenMove, whenUp, allProp){
				for (var key in allProp) {
					this[key] = allProp[key];
				}
				this.ondown = false;
				this.onmove = false;
				this.onup = false;
				if (typeof whenDown === 'function') this.ondown = (e)=>whenDown(e,this);
				if (typeof whenMove === 'function') this.onmove = (e)=>whenMove(e,this);	
				if (typeof whenUp === 'function') this.onup = (e)=>whenUp(e,this);					
			}
			load(){
				this.ondown ? document.addEventListener("mousedown", this.ondown) : null;
				this.onmove ? document.addEventListener("mousemove", this.onmove) : null;				
				this.onup ? document.addEventListener("mouseup", this.onup) : null;
			}
			destroy(){
				this.ondown ? document.removeEventListener("mousedown", this.ondown) : null;
				this.onmove ? document.removeEventListener("mousemove", this.onmove) : null;				
				this.onup ? document.removeEventListener("mouseup", this.onup): null;				
				delete this;
			}
		}
		class cursorClick extends cursor{
			constructor(button, repetition, whenDown, whenUp, objectRef) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};				
				switch(button) {
					case "left": button = 0; break;
					case "right": button = 2; break;
					default: break;
				}
				super();
				this.button = button;
				this.time = repetition;
				this.clicking = false;
				this.mouse = {
					x: 0,
					y: 0,
				}
				this.ondown = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
					if (!this.clicking) {
						this.clicking = true;
						whenDown(this.mouse, objectRef);
						if (repetition !== 0) this.clicking = setInterval(()=>whenDown(this.mouse, objectRef), repetition);
					}
				};
				this.onmove = (e)=>{
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
				};
				this.onup = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;										
					if (this.clicking) {
						whenUp(this.mouse, objectRef);
						if (repetition !== 0) clearInterval(this.clicking);
						this.clicking = false;
					}
				};
				this.load();
			}
		}
		/*class cursorClick {
			constructor(button, repetition, whenDown, whenUp, objectRef) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};				
				switch(button) {
					case "left": button = 0; break;
					case "right": button = 2; break;
					default: break;
				}
				//this.exe = func;
				this.button = button;
				this.time = repetition;
				this.clicking = false;
				this.mouse = {
					x: 0,
					y: 0,
				}
				this.ondown = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
					if (!this.clicking) {
						this.clicking = true;
						whenDown(this.mouse, objectRef);
						if (repetition !== 0) this.clicking = setInterval(()=>whenDown(this.mouse, objectRef), repetition);
					}
				};
				this.onmove = (e)=>{
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
				};
				this.onup = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;										
					if (this.clicking) {
						whenUp(this.mouse, objectRef);
						if (repetition !== 0) clearInterval(this.clicking);
						this.clicking = false;
					}
				};
				document.addEventListener("mousedown", this.ondown);
				document.addEventListener("mousemove", this.onmove);				
				document.addEventListener("mouseup", this.onup);
			}
			destroy(){
				document.removeEventListener("mousedown", this.ondown);
				document.removeEventListener("mousemove", this.onmove);				
				document.removeEventListener("mouseup", this.onup);				
				delete this;
				//this = undefined;
			}

		}
		*/
		var box = new collisionEntity(ENTITY, COLLISION, 0,0, 15*48, 15*48);
		const testData = [["444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444"],["444444",255,255,255,255,255,255,255,255,255,255,255,255,255,"444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","444444","ffffff","444444","444444","444444","444444","ffffff","444444","444444","444444","444444","444444","444444","444444"],[255,255,255,255,255,255,255,"ffffff",255,255,255,255,255,255,255]];
		const collisionTest = {"444444": "wall", 255: "wall"};		
		function readMap(rawData, collisionCheck, entity){
			//console.log(entity);
			//var map = new collisionEntity(0,0,15*48,15*48);
			// Row Check
			for (var i = 0; i < rawData.length; i++) {
				//var start = false;
				//var i = 1;
				var top = false;
				var bottom = false;
				for (var j = 0; j < rawData[i].length; j++) {
					// Exclude extraneous values
					//if (i != rawData.length-1 && i != 0) {
						//var top = rawData[i][j];
					//}
					var target = rawData[i][j];
					if (collisionCheck[target] != undefined) {
						if (i != 0 && top === false) 
							if (collisionCheck[rawData[i-1][j]] == undefined) 
								top = j;
						if (i != rawData.length-1 && bottom === false) 
							if (collisionCheck[rawData[i+1][j]] == undefined) 
								bottom = j;
					}
					if (top !== false) {
						if (collisionCheck[rawData[i-1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[i-1][j]] == undefined) {
								console.log(target, i, j);
								console.log(rawData[i][j-1]);
								j++;
							}
							console.log("TOP", i, top);
								entity.addCollision(top*48, i*48, (j-top)*48, "x");
								top = false;
						}
					}
					if (bottom !== false) {
						if (collisionCheck[rawData[i+1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							console.log("BOT", i, bottom);
							if (j == rawData[i].length-1 && collisionCheck[rawData[i+1][j]] == undefined) {
								j++;
							}
							entity.addCollision(bottom*48, (i+1)*48, (j-bottom)*48, "x");
							bottom = false;
						}
					}
				}
			}
			for (var i = 0; i < rawData.length; i++) {
				var left = false;
				var right = false;

				for (var j = 0; j < rawData[i].length; j++) {
					var target = rawData[j][i];
					if (collisionCheck[target] != undefined) {
						if (i != 0 && left === false) 
							if (collisionCheck[rawData[j][i-1]] == undefined) 
								left = j;
						if (i != rawData.length-1 && right === false) 
							if (collisionCheck[rawData[j][i+1]] == undefined) 
								right = j;
					}
					if (left !== false) {
						if (collisionCheck[rawData[j][i-1]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[j][i-1]] == undefined) {
								console.log(target, i, j);
								console.log(rawData[i][j-1]);
								j++;
							}
							console.log("LEFT", i, left);
								entity.addCollision(i*48, left*48, (j-left)*48, "y");
								left = false;
						}
					}
					if (right !== false) {
						if (collisionCheck[rawData[j][i+1]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							console.log("RIGHT", i, right);
							if (j == rawData[i].length-1 && collisionCheck[rawData[j][i+1]] == undefined) {
								j++;
							}
							entity.addCollision((i+1)*48, right*48, (j-right)*48, "y");
							right = false;
						}
					}
				}
			}			
		}
		/*class collision{
			constructor(){
				this.allWalls = arguments;
			}
		}*/
		var fps = document.getElementById("FPS");
		class refresh {
			constructor(){
				this.update = ()=>{
					canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
					var temp = Object.getOwnPropertySymbols(ENTITY);
					fps.innerHTML = temp.length;				
					for (var i = 0; i < temp.length; i++) {
						ENTITY[temp[i]].draw(canvas.ctx);
					}
				}
				this.testLoop = ()=>{
					setTimeout(()=>{
						this.testLoop();
					});
					this.update();
				}
				this.testLoop(()=>{requestAnimationFrame(this.update);}, 0);
				this.pause = false;
			}
			start(){
				this.pause = true;
			}
			stop(){
				this.pause = false;
			}
		}
		function testLoop(func, time){
			setTimeout(()=>{
				var temp = Date.now();
				//fps.innerHTML = Math.round(1000/(temp-time));
				testLoop(func, temp);
			}, 1000/60);
			func();
		}
		var update = ()=>{
			canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
			var temp = Object.getOwnPropertySymbols(ENTITY);
			fps.innerHTML = temp.length;				
			//canvas.ctx.drawImage(art["download2.png"], 0, 0);
			for (var i = 0; i < temp.length; i++) {
				ENTITY[temp[i]].draw(canvas.ctx);
				ENTITY[temp[i]].algorithm();
			}
			//console.log("LOL");
		}				
		function rand(min, max) {
			if (min === max) return max;
			return Math.round(Math.random()*(max-min) + min);
		}
		function rng(min, max, excludeMin, excludeMax) {
			var low = excludeMin-min;
			var high = max-excludeMax;
			var random = Math.round(this.rand(0, low+high+1));
			if (random >= 0 && random <= low) {
				return random+min;
			} else if (random > low && random <= low+high+1) {
				return random-low+excludeMax;
			}
		}
			//var canvas = canvasGen();
	var canvas = new layer((window.innerWidth-15*SCALE)/2, 1, 15*SCALE, 15*SCALE, false, 0);
	canvas.show();
	canvas.element.style["z-index"] = 0;	
		/*async function start(){			
			document.addEventListener("contextmenu", (e)=>e.preventDefault());
			var art = await loadImages(["test.png", "testBack.png", "enemy.png", "enemyBack.png", "target.png", "newEnemy.png", "orb.png", "download3.png"]);
			var lvl1 = new layer((window.innerWidth-15*Math.floor(window.innerHeight/15))/2, 1, 15*Math.floor(window.innerHeight/15), 15*Math.floor(window.innerHeight/15), art["download3.png"]);

			var mainPlayer = new player([art["test.png"], art["testBack.png"]], 300, 300, 36, 40, 6, 8, 48,48);
			//var box = new collisionEntity(0,0, 703, 703);
			box.addCollision(0,canvas.height,canvas.width, "x");
			//box.addCollision(0,0,canvas.height, "y");
			//box.addCollision(0,canvas.height,canvas.width, "x");
			//box.addCollision(canvas.width,0,canvas.height, "y");
			box.prop["type"] = "wall";
			var drawCollision = ()=>{
				var xDir = box.colArea.x;
				var yDir = box.colArea.y;
				for (var i = 0; i < xDir.length; i++) {
					var temp = xDir[i];
					lvl1.ctx.fillStyle = 'red';
					lvl1.ctx.fillRect(temp.x-1, temp.y,2, temp.distance);
				}
				for (var i = 0; i < yDir.length; i++) {
					var temp = yDir[i];
					lvl1.ctx.fillStyle = 'blue';
					lvl1.ctx.fillRect(temp.x, temp.y-1,temp.distance,2);
				}
			};
			mainPlayer.oncollision((c, o)=>{if(o.prop["type"] == "wall") console.log(c);});
			mainPlayer.speed = 4;			
			mainPlayer.onCursorMove("face", (mouse, playerData)=>{
				if (playerData.moving()) return;
				if (mouse.y-32 < mainPlayer.y) playerData.index = 1;
				else playerData.index = 0;				
			});
			mainPlayer.onmove("KeyS", 1, "y", 0, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});
			mainPlayer.onmove("KeyW", -1, "y", 1, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});			
			mainPlayer.onmove("KeyA", -1, "x", null, false, false);
			mainPlayer.onmove("KeyD", 1, "x", null, false, false);	
			mainPlayer.onCursorClick("leftClick", "left", 1000/60, (mouse, playerData)=>{
				var temp = new entity([art["orb.png"]], playerData.x+32-4, playerData.y+32-4, 8, 8, 4, 4);
				//Offset height - offset
				temp.oncollision((c, o)=>{if(o.prop["type"] == "wall") c.destroy();});
				temp.moveTo(mouse.x-4-canvas.x, mouse.y-4-canvas.y, ()=>{});
				temp.speed = 10;
			}, false);
			testLoop(()=>{requestAnimationFrame(update);}, 0);
					readMap(testData, collisionTest);
					drawCollision();
		}*/
		testLoop(()=>{requestAnimationFrame(update);}, 0);
		//start();
	</script>
	<script>
		//const REFRESH = new refresh();
		const PLAYER = async ()=>{
			var allImages = ["test.png", "testBack.png", "orb.png"];			
			var playerArt = await loadImages(allImages);
			var mainPlayer = new player(false, false, [playerArt["test.png"], playerArt["testBack.png"]], 7*SCALE, 5*SCALE, Math.round(36/48*SCALE), Math.round(40/48*SCALE), 0.125*SCALE, Math.round(6/48*SCALE), SCALE,SCALE);
			mainPlayer.oncollision((c, o, i)=>{
				var direction = "";
				if (i["x"] != undefined) {
					if (i["x"] == 0) {
						direction = "W";
					} else direction = "E";
				} else {
					if (i["y"] == 0) {
						direction = "N";
					} else direction = "S";
				}
				if(o.prop["type"] == "wall" && o.prop["room"] != undefined) o.prop["room"].changeRoom(direction);
			});
			mainPlayer.speed = 4;			
			mainPlayer.onCursorMove("face", (mouse, playerData)=>{
				if (playerData.moving()) return;
				if (mouse.y-32 < mainPlayer.y) playerData.index = 1;
				else playerData.index = 0;				
			});
			mainPlayer.onmove("KeyS", 1, "y", 0, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});
			mainPlayer.onmove("KeyW", -1, "y", 1, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});			
			mainPlayer.onmove("KeyA", -1, "x", null, false, false);
			mainPlayer.onmove("KeyD", 1, "x", null, false, false);	

			mainPlayer.hitbox(true);
			mainPlayer.onCursorClick("leftClick", "left", 0, (mouse, playerData)=>{
				var temp = new entity(ENTITY, COLLISION, [playerArt["orb.png"]], playerData.x+playerData.hit.offWidth/2-4, playerData.y+playerData.hit.offHeight/2-4, 8, 8, 4, 4);
				//Offset height - offset
				temp.oncollision((c, o, i)=>{
					if(o.prop["type"] == "wall" || o.prop["type"] == "room") c.destroy();
					else if(o.prop["type"] == "enemy"){
						c.destroy();
						if (o.prop["hp"] > 0) o.prop["hp"]--;
						else o.destroy();
					} else return i.old;
				});
				temp.moveTo(mouse.x-4-canvas.x, mouse.y-4-canvas.y, ()=>{});
				temp.speed = 10;
				//playerData.tp(mouse.x-4-canvas.x-playerData.hit.offWidth/2, mouse.y-4-canvas.y-playerData.hit.offHeight/2);
				//playerData.hitbox(true);
			}, false);
			return mainPlayer;
		}
		var MAINPLAYER = false;
			var createLayer = async (art, index)=>{
				return new layer((window.innerWidth-15*SCALE)/2, 1, 15*SCALE, 15*SCALE, (await loadImages([art]))[art], index);
			};
		class room {
			constructor(mapName, level){
				this.level = level;
				this.botLayer = null;
				this.topLayer = null;
				this.mapName = mapName;
				this.entities = {};
				this.collision = {};
				this.N = null;
				this.W = null;
				this.S = null;
				this.E =  null;
				this.collisionLayer = new collisionEntity(this.entities, this.collision, 0,0,canvas.height, canvas.width);
				//this.collisionLayer.prop["type"] = "wall";
				this.box = new collisionEntity(this.entities, this.collision, 0,0,canvas.height, canvas.width);
				this.box.prop["type"] = "wall";
				this.box.prop["room"] = this;
				this.box.addCollision(0,0,canvas.width, "x");
				this.box.addCollision(0,0,canvas.height, "y");
				this.box.addCollision(0,canvas.height,canvas.width, "x");
				this.box.addCollision(canvas.width,0,canvas.height, "y");

				this.entities[MAINPLAYER.id] = MAINPLAYER;
				this.collision[MAINPLAYER.id] = MAINPLAYER;
			}
			load() {
				this.botLayer.show();
				this.topLayer.show();
			}
			unload() {
				this.botLayer.hide();
				this.topLayer.hide();
			}
			async layer() {
				this.botLayer = await createLayer(`${this.level}/Map${this.mapName}.png`, -10);
				this.topLayer = await createLayer(`${this.level}/Map${this.mapName}Top.png`, 10);
			}
			readMap(rawData, collisionCheck){
			for (var i = 0; i < rawData.length; i++) {
				//var start = false;
				//var i = 1;
				this.collisionLayer.prop["type"] = "room";
				var top = false;
				var bottom = false;
				for (var j = 0; j < rawData[i].length; j++) {
					var target = rawData[i][j];
					if (collisionCheck[target] != undefined) {
						if (i != 0 && top === false) 
							if (collisionCheck[rawData[i-1][j]] == undefined) 
								top = j;
						if (i != rawData.length-1 && bottom === false) 
							if (collisionCheck[rawData[i+1][j]] == undefined) 
								bottom = j;
					}
					if (top !== false) {
						if (collisionCheck[rawData[i-1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[i-1][j]] == undefined) {
								j++;
							}
								this.collisionLayer.addCollision(top*SCALE, i*SCALE, (j-top)*SCALE, "x");
								top = false;
						}
					}
					if (bottom !== false) {
						if (collisionCheck[rawData[i+1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[i+1][j]] == undefined) {
								j++;
							}
							this.collisionLayer.addCollision(bottom*SCALE, (i+1)*SCALE, (j-bottom)*SCALE, "x");
							bottom = false;
						}
					}
				}
			}
			for (var i = 0; i < rawData.length; i++) {
				var left = false;
				var right = false;

				for (var j = 0; j < rawData[i].length; j++) {
					var target = rawData[j][i];
					if (collisionCheck[target] != undefined) {
						if (i != 0 && left === false) 
							if (collisionCheck[rawData[j][i-1]] == undefined) 
								left = j;
						if (i != rawData.length-1 && right === false) 
							if (collisionCheck[rawData[j][i+1]] == undefined) 
								right = j;
					}
					if (left !== false) {
						if (collisionCheck[rawData[j][i-1]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[j][i-1]] == undefined) {
								j++;
							}
								this.collisionLayer.addCollision(i*SCALE, left*SCALE, (j-left)*SCALE, "y");
								left = false;
						}
					}
					if (right !== false) {
						if (collisionCheck[rawData[j][i+1]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[j][i+1]] == undefined) {
								j++;
							}
							this.collisionLayer.addCollision((i+1)*SCALE, right*SCALE, (j-right)*SCALE, "y");
							right = false;
						}
					}
				}
			}			
		}
			connect(otherRoom, side){
				switch(side) {
					case "N":
						this.N = otherRoom;
						otherRoom.S = this;
						break;
					case "W":
						this.W = otherRoom;
						otherRoom.E = this;
						break;
					case "S":
						this.S = otherRoom;
						otherRoom.N = this;
						break;
					case "E":
						this.E = otherRoom;
						otherRoom.W = this;
						break;
					default: break;
				}
			}
			changeRoom(direction){
				this.unload();
				switch(direction) {
					case "N": 
						MAINPLAYER.tp(false, canvas.height - MAINPLAYER.hit.offHeight);
						break;
					case "W":
						MAINPLAYER.tp(canvas.width - MAINPLAYER.hit.offWidth);
						break;
					case "S":
						MAINPLAYER.tp(false, 1);
						break;
					case "E":
						MAINPLAYER.tp(1);
						break;
					default: break;
				}
				this[direction].load();				
				COLLISION = this[direction].collision;
				ENTITY = this[direction].entities;
			}
		}
		async function get(path, data) {
			return new Promise(async (resolve, reject)=>{		
				var temp = new XMLHttpRequest();
				temp.open('GET', path, true);
				temp.send();
					temp.onreadystatechange = ()=>{
						if (temp.readyState === 4) {
							//var data = JSON.parse(temp.response);
							//if (data.msg) resolve(data.msg);
							resolve(temp.response);
						}
					};
				});
		}
		async function levelGen(array, level){
			if (!MAINPLAYER) MAINPLAYER = await PLAYER();
			var allRooms = array;
			var roomData = [];
			for (var a = 0; a < allRooms.length; a++) {
				var temp = [];
				for (var b = 0; b < allRooms[a].length; b++) {
					if (allRooms[a][b] == null) {
						temp.push(null);
						continue;
					}
					var rooms = new room(allRooms[a][b], level); 
					await rooms.layer();
					var mapData = await get(`/${level}/Map${allRooms[a][b]}.json`);
					//readMap(mapData, collisionTest, rooms.collisionLayer);
					rooms.readMap(JSON.parse(mapData), collisionTest);
					temp.push(rooms);
				}
				roomData.push(temp);
			}
			return roomData;
		}
		var simpleTarget = (c)=>{
			if (Math.abs(MAINPLAYER.x-c.x) > c.speed){
				if (c.x < MAINPLAYER.x) {
					c.moveX(c.x+c.speed);
				} else if (c.x > MAINPLAYER.x) c.moveX(c.x-c.speed);
			}
			if (Math.abs(MAINPLAYER.y-c.y) > c.speed) {
				if (c.y < MAINPLAYER.y) {	
					c.moveY(c.y+c.speed);
				} else if (c.y > MAINPLAYER.y) c.moveY(c.y-c.speed);	
			}
		}
		var randMove = (c)=>{
			if (c.moveToLoop) {
				return;
			}
			var temp = rand(1,15);
			var temp2 = rand(1,15);		
			c.moveTo(temp*SCALE, temp2*SCALE);			
		}
		class inventory {
			constructor(x, y, width, squareWidth){
				this.items = [[null, null, null, null],
							  [null, null, null, null],
							  [null, null, null, null],
							  [null, null, null, null],
							  [null, null, null, null]];
				this.width = width;
				this.inv = document.createElement("DIV");
				this.inv.classList.add("inventory");
				this.inv.style.width = this.width + "px";
				this.inv.style.height = this.width + "px";
				this.inv.style.top = y + "px";
				this.inv.style.left = x + "px";
				document.body.appendChild(this.inv);
				var remainder = (width - squareWidth*4)/5;
				var id = 0;
				for (var i = 0; i < 4; i++) {
					for (var j = 0; j < 4; j++) {
						id++;
						this.items[i][j] = {
							element: this.genInv(j*squareWidth+(j+1)*remainder-2, i*squareWidth+(i+1)*remainder-2, squareWidth, id),
							item: null,
						};
						this.inv.appendChild(this.items[i][j].element);
					}
				}
				this.press = false;
				this.drag = false;
				this.target = false;
				this.hover = false;
				//button, repetition, whenDown, whenUp, objectRef
				this.cursor = {
					press: new cursor((e, i)=>{
						/*if (i.down) return; 
						i.down = true; 
						console.log(e);*/
					}, (e, i)=>{
						/*if (!i.down) return;
						i.x = e.clientX-32; i.y = e.clientY-32;
						//var temp = e.path[2];
						if (!i.img) {
							if ((e.path[1]).classList.contains("slot")) i.img = e.srcElement;
						}
						else {
							i.img.style.pointerEvents = "none";
							i.img.style.position = "fixed";
							i.img.style.top = i.y + "px";
							i.img.style.left = i.x + "px";
						}*/
						if (!this.target) return;
						if (this.getSlot(this.target).item == null) return;
						console.log(this.getSlot(this.target));
						var image = this.getSlot(this.target).item.img;
						i.x = e.clientX-32; i.y = e.clientY-32;
						image.style.position = "fixed";
						image.style.top = i.y + "px";
						image.style.left = i.x + "px";
					}, (e, i)=>{
						console.log(this.target, this.hover);
						if (!this.target) return;
						if (this.hover) return;
						if (this.getSlot(this.target).item == null) return;	
						console.log("UP");	
						var image = this.getSlot(this.target).item.img;
						image.style.top = "initial";
						image.style.left = "initial";
						image.style.position = "absolute";
						/*if (this.hover && this.hover !== this.target) {
							var switcher = null;
							if (this.getSlot(this.hover).item !== null) {
								switcher = this.getSlot(this.hover).item;
								switcher.remove();	
								this.getSlot(this.id).element.appendChild(switcher);
							}
							image.remove();
							this.getSlot(this.hover).element.appendChild(image);
							if (switcher) {
								this.getSlot(this.hover).item = image;
								this.getSlot(this.id).item = switcher;
							} else {
								this.getSlot(this.hover).item = image;
								this.getSlot(this.id).item = null;
							}
						}	
						i.lock = false;*/
						this.target = false;											

											/*if (i.down) i.down = false;
						if (i.img) {
							i.img.style.top = "initial";
							i.img.style.left = "initial";
							i.img.style.position = "absolute";
							if (e.srcElement.classList.contains("slot")) {
								i.img.remove();	
								e.srcElement.appendChild(i.img);
							}
							i.img = null
						}*/
					}, {
						x: null, 
						y: null
					})
				}
				this.cursor.press.load();
				console.log(this.cursor.press);
				//this.cursor.press.ondown = (e, obj)=>{console.log(e)}
				/*for (var i = 0; i < 4; i++) {
					this.items[i][j] = this.genInv(remainder-2, j*squareWidth+(j+1)*remainder-2, squareWidth);
					this.inv.appendChild(this.items[0][i]);
				}*/
			}
			genInv(x,y,width,id){
				var temp = document.createElement("DIV");
				temp.classList.add("slot");
				temp.id = id;
				temp.style.width = width + "px";
				temp.style.height = width + "px";
				temp.style.top = y + "px";
				temp.style.left = x + "px";
				temp.addEventListener("mousedown", ()=>{
					if (!this.target) this.target = id;
					console.log(id);
				});
				/*temp.addEventListener("mouseover", ()=>{
					this.hover = id;
				});*/
				temp.addEventListener("mouseup", ()=>{
					this.hover = id;
					if (!this.target) return;
					if (this.getSlot(this.target).item == null) {
						this.target = false;
						this.hover = false;
						return;	
					}
					console.log("UP");	
					console.log((this.getSlot(this.target)).item);
					var firstItem = (this.getSlot(this.target)).item;
					var image = (this.getSlot(this.target)).item.img;
					image.style.top = "initial";
					image.style.left = "initial";
					image.style.position = "absolute";
					if (this.hover && this.hover !== this.target) {
						var switcher = null;
						if (this.getSlot(this.hover).item !== null) {
							switcher = this.getSlot(this.hover).item;
							switcher.img.remove();	
							this.getSlot(this.target).element.appendChild(switcher.img);
						}
						image.remove();
						this.getSlot(this.hover).element.appendChild(image);
						if (switcher) {
							this.getSlot(this.hover).item = firstItem;
							this.getSlot(this.target).item = switcher;
						} else {
							this.getSlot(this.hover).item = firstItem;
							this.getSlot(this.target).item = null;
						}
					}	
					this.target = false;	
					this.hover = false;
				});
				return temp;				
			}
			getSelected(){
				return [this.items[0], this.items[1], this.items[2], this.items[3]];
			}
			getSlot(index) {
				var row = Math.floor((index-1)/4);
				return this.items[row][(index-1)%4];

			}
			setItem(slot, item) {
				this.getSlot(slot).item = item;
				this.getSlot(slot).element.appendChild(item.img);
			}
		}
		var INVENTORY = new inventory(5, 6.25*SCALE, (window.innerWidth-15*SCALE)/2-20, 70/48*SCALE);
		class item {
			constructor(image, properties){
				this.img = image;
				this.active = false;
				this.passive = null;
				this.img.classList.add("item");
				for (var key in properties) {
					this[key] = properties[key];
				}
			}

		}
		async function level1(){
			var staffData = await loadImages(["staff.png", "randoRing.png"]);
			INVENTORY.setItem(16, new item(staffData["staff.png"]));
			INVENTORY.setItem(1, new item(staffData["randoRing.png"]));
			var allRooms = [["SE", "WS", "S"],
							["NE", "NWS", "NS"],
							[null, "NE", "NW"]];
			var roomData = await levelGen(allRooms, "lvl1");
			var otherArt = await loadImages(["art/woodenChest.png", "test.png"]);
			console.log(roomData);
			roomData[0][0].load();
			COLLISION = roomData[0][0].collision;
			ENTITY = roomData[0][0].entities;
			roomData[0][0].connect(roomData[1][0], "S");
			roomData[0][0].connect(roomData[0][1], "E");
			roomData[0][1].connect(roomData[1][1], "S");
			roomData[1][0].connect(roomData[1][1], "E");
			roomData[1][1].connect(roomData[2][1], "S");
			roomData[2][1].connect(roomData[2][2], "E");
			roomData[2][2].connect(roomData[1][2], "N");
			roomData[1][2].connect(roomData[0][2], "N");
				var temp = new entity(roomData[0][0].entities, roomData[0][0].collision, [otherArt["art/woodenChest.png"]], 7*SCALE, 7*SCALE, false, false, false, false, SCALE,SCALE);	
				temp.hitbox(0.125*SCALE, 0.125*SCALE, 0.75*SCALE, 0.75*SCALE);				
			var randEnemy = (roomInfo, count)=>{	
				for (var i = 0; i < count; i++) {
					var enemy = new entity(roomInfo.entities, roomInfo.collision, [otherArt["test.png"]], rand(1,13)*SCALE, rand(2,13)*SCALE, Math.round(36/48*SCALE), Math.round(40/48*SCALE), 0.125*SCALE, Math.round(6/48*SCALE), SCALE,SCALE);
					enemy.addAlgorithm(randMove);
					enemy.prop["type"] = "enemy";
					enemy.prop["hp"] = 10;
					enemy.speed = 2;
					enemy.hitbox(true);
					enemy.oncollision((c,o)=>{
						if(o.prop["type"] == "wall" || o.prop["type"] == "room") {
							c.stopMoving();
						}
					});
					enemy.oncollision((c,o,i)=>{return (o.prop["type"] === "enemy") ? i.old : false;});
				}
			}
			var simpleEnemy = (roomInfo, count)=>{	
				for (var i = 0; i < count; i++) {
					var enemy = new entity(roomInfo.entities, roomInfo.collision, [otherArt["test.png"]], rand(1,13)*SCALE, rand(2,13)*SCALE, Math.round(36/48*SCALE), Math.round(40/48*SCALE), 0.125*SCALE, Math.round(6/48*SCALE), SCALE,SCALE);
					enemy.addAlgorithm(simpleTarget);
					enemy.prop["type"] = "enemy";
					enemy.prop["hp"] = 10;

					enemy.speed = 2;
					enemy.hitbox(true);
					enemy.oncollision((c,o)=>{
						if(o.prop["type"] == "wall" || o.prop["type"] == "room") {
							c.stopMoving();
						}
						});
				}
			}
			// When player is out, it tps the player.
			simpleEnemy(roomData[0][0], 1);
			simpleEnemy(roomData[2][2], 1);
			simpleEnemy(roomData[1][2], 1);
			randEnemy(roomData[0][1], 3);
			randEnemy(roomData[1][0], 3);
			randEnemy(roomData[2][1], 3);
		}

		level1();
	</script>
	<script>
		async function level2(){
			var allRooms = [["E","WE","WS"],
							["E","WSE","NW"],
							["E","NWSE","W"],
							[null,"N",null]];
			var roomData = await levelGen(allRooms, "lvl2");
			roomData[0][0].connect(roomData[0][1], "E");
			roomData[0][1].connect(roomData[0][2], "E");
			roomData[1][0].connect(roomData[1][1], "E");
			roomData[1][1].connect(roomData[1][2], "E");
			roomData[2][0].connect(roomData[2][1], "E");
			roomData[2][1].connect(roomData[2][2], "E");
			roomData[1][2].connect(roomData[0][2], "N");
			roomData[1][1].connect(roomData[2][1], "S");
			roomData[2][1].connect(roomData[3][1], "S");
			roomData[2][1].load();
			COLLISION = roomData[2][1].collision;
			ENTITY = roomData[2][1].entities;
		}

		//level2();
	</script>
	<script>
		async function level3(){
			var allRooms = [["None"]];
			var roomData = await levelGen(allRooms, "lvl3");
			console.log(roomData);
			roomData[0][0].load();
			COLLISION = roomData[0][0].collision;
			ENTITY = roomData[0][0].entities;
		}
		//level3();
	</script>
	<script>
		async function level4(){
			var allRooms = [["S","S",null],
							["NE","NWSE","W"],
							["E","NWSE","W"],
							[null,"N",null]];
			var roomData = await levelGen(allRooms, "lvl4");
			roomData[0][0].connect(roomData[1][0], "S");
			roomData[0][1].connect(roomData[1][1], "S");
			roomData[1][0].connect(roomData[1][1], "E");
			roomData[1][1].connect(roomData[1][2], "E");
			roomData[2][0].connect(roomData[2][1], "E");
			roomData[2][1].connect(roomData[2][2], "E");
			roomData[1][1].connect(roomData[2][1], "S");
			roomData[2][1].connect(roomData[3][1], "S");
			roomData[3][1].load();
			COLLISION = roomData[3][1].collision;
			ENTITY = roomData[3][1].entities;					
		}
		//level4();
	</script>
</body>
</html>