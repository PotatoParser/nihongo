<!DOCTYPE HTML>
<html>
<body style="overflow: hidden; margin: none; border: none; outline: none">
	<style>
	canvas{
		outline: 5px solid black;
	}
	html{
		cursor: url("cursor.png") 8 8, pointer;
		background-color: #111111;
	}
	div{
		position: fixed;
		top: 10px;
		font-size: 40px;
		left: 10px;
		user-select: none;
		pointer-events: none;
		color: white;
	}
</style>
<div id="FPS">0</div>
	<script>
		// (C) Wilson Nguyen
		// Faster method if you create a queue mechanic
		// Use webworkers to speed up processing speed
		function canvasGen(){
			var temp = document.createElement("CANVAS");
			temp.id = "screen";
			temp.width = window.innerHeight-20;
			temp.height = window.innerHeight-20;
			temp.style=`position: fixed; top: 10px; left: ${(window.innerHeight-20)/2}px;`;
			document.body.appendChild(temp);
			return {
				width: window.innerHeight-20,
				height: window.innerHeight-20,
				x: (window.innerHeight-20)/2,
				y: 10,
				ctx: temp.getContext("2d"),
			}
		}
		function createEntity(){

		}
	</script>
	<script>
		async function loadImages(arrImages){
			var temp = {};
			for (var i = 0; i < arrImages.length; i++) {
				var other = new Image();
				other.src = arrImages[i];
				await new Promise((resolve)=>{
					other.onload = ()=>{
						resolve();
					}
				});
				temp[arrImages[i]] = other;
			}
			return temp;
		}
		var ENTITY = {};
		var COLLISION = {};
		class layer {
			constructor(x, y, width, height, image){
				this.element = document.createElement("CANVAS");
				this.img = image || null;
				this.x = x || 0;
				this.y = y || 0;
				this.width = width || 100;
				this.height = height || 100;
				document.body.appendChild(this.element);
				this.ctx = this.element.getContext("2d");
				this.setPosition();
				this.setDimension();
				this.reload();				
			}
			reload(){
				if (this.img != null) {
					this.ctx.drawImage(this.img, 0, 0, this.width, this.height);
				}
			}
			setPosition(x, y){
				this.element.style.position = "fixed";
				this.element.style.left = `${x || this.x}px`;
				this.element.style.top = `${y || this.y}px`;
				this.element.style["z-index"] = "-10";
			}
			setDimension(width, height) {
				this.element.width = width || this.width;
				this.element.height = height || this.height;
			}
		}
		class key{
			constructor(keyCode, whenDown, whenUp, speed){
				this.mainKey = keyCode;
				this.keyDown = false;
				this.whenDown = (e)=>{
					if (e.code != this.mainKey) return;
					if (!this.keyDown) {
						this.keyDown = true;
						whenDown();
						if (speed != 0) this.keyDown = setInterval(whenDown, speed);
					}
				};
				this.whenUp = (e)=>{
					if (e.code != this.mainKey) return;					
					if (this.keyDown) {
						whenUp();
						if (speed != 0) clearInterval(this.keyDown);
						this.keyDown = false;
					}
				};
				document.addEventListener("keydown", this.whenDown);
				document.addEventListener("keyup", this.whenUp);
			}
			destroy(){
				if (this.keyDown) clearInterval(this.keyDown);
				document.removeEventListener("keydown", this.whenDown);
				document.removeEventListener("keyup", this.whenUp);
				delete this;
			}
		}
		function distance(x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
		}		
		function ERR(actual, calc){
			if (Math.round(actual) == Math.round(calc)) console.log("PERFECT");
			else console.log(Math.round((actual-calc)/calc*100) + "%");
		}
		class entity{
			constructor(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				this.img = image;
				this.x = x || 0;
				this.y = y || 0;
				this.height = height || image[0].height;
				this.width = width || image[0].width;			
				this.index = 0;
				this.speed = 1;
				this.moveToLoop = false;
				this.id = Symbol();
				this.prop = {};
				this.hit = {
					offX: offsetX || 0,
					offY: offsetY || 0,
					offWidth: (hitWidth || this.width),
					offHeight: (hitHeight || this.height),
				}
				this.collisionEvent = [];
				this.colArea = {
					x: [],
					y: []
				}
				this.still = false,
				ENTITY[this.id] = this;				
			}
			draw(ctx){
				if (!this.still) ctx.drawImage(this.img[this.index], this.x-this.hit.offX, this.y-this.hit.offY, this.width, this.height);
			}
			tp(x,y){
				this.x = x;
				this.y = y;
			}
			moveX(newX){
				if (newX < this.x) this.x = this.checkAllX(this.y, this.hit.offHeight, this.x, newX);
				else this.x = this.checkAllX(this.y, this.hit.offHeight, this.x, newX+this.hit.offWidth)-this.hit.offWidth;				
			}			
			moveY(newY){
				if (newY < this.y) this.y = this.checkAllY(this.x, this.hit.offWidth, this.y, newY);
				else this.y = this.checkAllY(this.x, this.hit.offWidth, this.y, newY+this.hit.offHeight)-this.hit.offHeight;
			}			
			moveTo(x, y, reach){
				//One pixel every frame
				this.stopMoving();
				var rise = y-this.y, run = x-this.x, dist = distance(x,y,this.x,this.y), xPos = 1, yPos = 1;
				if (rise < 0) yPos = -1;
				if (run < 0) xPos = -1;
				this.moveToLoop = true;
				this.moveToLoop = setInterval(()=>{
					var tempY = this.y + rise/dist*this.speed;
					var tempX = this.x + run/dist*this.speed;
					if ((tempX-x)*xPos >= 0 && (tempY-y)*yPos >= 0){ // -x means that tempY is negative 
						if (!reach) {
							this.moveY(y);
							this.moveX(x);
							this.stopMoving();							
							return;
						} else reach(this,x,y);
					}
					this.moveY(tempY);
					this.moveX(tempX);
				}, 1000/60);
			}					
			stopMoving(){
				// Not currently rounding!!!!
				if (this.moveToLoop) {
					clearInterval(this.moveToLoop);
					this.moveToLoop = false;
				}
			}
			oncollision(func){
				this.collisionEvent.push(func);
			}
			checkAllY(x, dist, y1, y2){
				var allEnt = Object.getOwnPropertySymbols(COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;		
					for (var i = 0; i < ENTITY[allEnt[b]].colArea.y.length; i++) {
						var temp = ENTITY[allEnt[b]].colArea.y[i].check(x, dist, y1, y2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								console.log(x, y1, y2, temp);
								var atImpact = this.collisionEvent[a](this, temp.impact);
								if (atImpact) return atImpact;
							}
						}
						y2 = temp.y;
					}
				}
				return y2;
			}
			checkAllX(y, dist, x1, x2){
				var allEnt = Object.getOwnPropertySymbols(COLLISION);
				for (var b = 0; b < allEnt.length; b++) {
					if (allEnt[b] == this.id) continue;	
					for (var i = 0; i < ENTITY[allEnt[b]].colArea.x.length; i++) {
						var temp = ENTITY[allEnt[b]].colArea.x[i].check(y, dist, x1, x2);
						if (temp.impact) {
							for (var a = 0; a < this.collisionEvent.length; a++) {
								console.log(temp);
								var atImpact = this.collisionEvent[a](this, temp.impact);
								if (atImpact) return atImpact;
							}
						}		
						x2 = temp.x;
					}
				}
				return x2;
			}		
			destroy(){
				if (this.moveToLoop) clearInterval(this.moveToLoop);
				delete ENTITY[this.id];
				delete COLLISION[this.id];				
				delete this;
			}
			addCollision(x, y, distance, direction){
				COLLISION[this.id] = this;
				var exists = false;
				switch(direction) {
					case "y": 
						for (var i = 0; i < this.colArea.x.length; i++) 
							if (this.colArea.x[i].x == x && this.colArea.x[i].y == y && this.colArea.x[i].distance == distance) 
								exists = true;
						this.colArea.x.push(new wall(x, y, distance, direction, this)); 
						break;
					case "x": 
						for (var i = 0; i < this.colArea.y.length; i++) 
							if (this.colArea.y[i].x == x && this.colArea.y[i].y == y && this.colArea.y[i].distance == distance) 
								exists = true;
						if (!exists) this.colArea.y.push(new wall(x, y, distance, direction, this)); 
						break;
					default: break;
				}
			}
		}	
		class thread {
			constructor(file) {
				this.Thread = new Worker(file);
			}
			send(data){
				this.Thread.postMessage(data);	
			}

		}
		class collisionEntity extends entity{
			constructor(boxX, boxY, boxHeight, boxWidth){
				super(null, 0, 0, 0, 0, 0, 0, 1, 1);
				this.still = true;
				this.speed = 0;
				this.img = null;
			}
		}

		// offset of 8, hitHeight of 
		class player extends entity{
			constructor(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height){
				super(image, x, y, hitWidth, hitHeight, offsetX, offsetY, width, height);
				this.movement = [];
				this.controls = {};
				this.mouseControls = {};
			}
			onmove(keyCode, reversed, type ,imageIndex, whenDown, whenUp) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};					
				//whenDown = whenDown || ()=>{};
				this.controls[keyCode] = new key(keyCode, ()=>{
					if (type === "x") this.moveX(this.x+reversed*this.speed);
					else if(type === "y") this.moveY(this.y+reversed*this.speed);
					if (!(imageIndex === null)) this.index = imageIndex;
					this.move(keyCode);					
					whenDown();
				}, ()=>{
					this.stop(keyCode);
					whenUp();
				}, 1000/60);				
			}
			move(key){
				var temp = this.movement.indexOf(key);
				if (temp == -1) this.movement.push(key);
			}
			stop(key) {
				var temp = this.movement.indexOf(key);
				if (temp == -1) return false;				
				this.movement.splice(temp, 1);
			}
			moving(){
				return this.movement.length != 0;
			}	
			onCursorMove(label, func){
				this.mouseControls[label] = new cursorMove(func, this);
			}
			onCursorClick(label, button, repetition, whenDown, whenUp){
				this.mouseControls[label] = new cursorClick(button, repetition, whenDown, whenUp, this);
			}
			clean(){
				for (var key in this.controls) {
					this.controls[key].destroy();
				}
				for (var key in this.mouseControls) {
					this.mouseControls[key].destroy();
				}
				this.destroy();
			}
		}
		class cursorMove{
			constructor(func, objectRef) {
				this.mousePos = {
					x: 0,
					y: 0
				};
				this.exe = ()=>{func(this.mousePos, objectRef);};
				document.addEventListener("mousemove", (e)=>{
					this.mousePos.x = e.clientX;
					this.mousePos.y = e.clientY;
					this.exe();
				});
			}
		}
		class cursorClick {
			constructor(button, repetition, whenDown, whenUp, objectRef) {
				if (typeof whenUp !== 'function') whenUp = ()=>{};
				if (typeof whenDown !== 'function') whenDown = ()=>{};				
				switch(button) {
					case "left": button = 0; break;
					case "right": button = 2; break;
					default: break;
				}
				//this.exe = func;
				this.button = button;
				this.time = repetition;
				this.clicking = false;
				this.mouse = {
					x: 0,
					y: 0,
				}
				this.ondown = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
					if (!this.clicking) {
						this.clicking = true;
						whenDown(this.mouse, objectRef);
						if (repetition !== 0) this.clicking = setInterval(()=>whenDown(this.mouse, objectRef), repetition);
					}
				};
				this.onmove = (e)=>{
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;
				};
				this.onup = (e, targetObj)=>{
					if (e.button !== this.button) return;
					this.mouse.x = e.clientX;
					this.mouse.y = e.clientY;										
					if (this.clicking) {
						whenUp(this.mouse, objectRef);
						if (repetition !== 0) clearInterval(this.clicking);
						this.clicking = false;
					}
				};
				document.addEventListener("mousedown", this.ondown);
				document.addEventListener("mousemove", this.onmove);				
				document.addEventListener("mouseup", this.onup);
			}
			destroy(){
				document.removeEventListener("mousedown", this.ondown);
				document.removeEventListener("mousemove", this.onmove);				
				document.removeEventListener("mouseup", this.onup);				
				delete this;
				//this = undefined;
			}

		}
		var box = new collisionEntity(0,0, 15*48, 15*48);
		const testData = [["444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444","444444"],["444444",255,255,255,255,255,255,255,255,255,255,255,255,255,"444444"],["ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","aaaaaa"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","ffffff","444444"],["444444","444444","444444","444444","444444","444444","444444","ffffff","444444","444444","444444","444444","444444","444444","444444"],[255,255,255,255,255,255,255,"ffffff",255,255,255,255,255,255,255]];
		const collisionTest = {"444444": "wall", 255: "wall"};		
		function readMap(rawData, collisionCheck){
			var map = new collisionEntity(0,0,15*48,15*48);
			// Row Check
			for (var i = 0; i < rawData.length; i++) {
				//var start = false;
				//var i = 1;
				var top = false;
				var bottom = false;
				for (var j = 0; j < rawData[i].length; j++) {
					// Exclude extraneous values
					//if (i != rawData.length-1 && i != 0) {
						//var top = rawData[i][j];
					//}
					var target = rawData[i][j];
					if (collisionCheck[target] != undefined) {
						if (i != 0 && top === false) 
							if (collisionCheck[rawData[i-1][j]] == undefined) 
								top = j;
						if (i != rawData.length-1 && bottom === false) 
							if (collisionCheck[rawData[i+1][j]] == undefined) 
								bottom = j;
					}
					if (top !== false) {
						if (collisionCheck[rawData[i-1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							if (j == rawData[i].length-1 && collisionCheck[rawData[i-1][j]] == undefined) {
								console.log(target, i, j);
								console.log(rawData[i][j-1]);
								j++;
							}
							console.log("TOP", i, top);
								box.addCollision(top*48, i*48, (j-top)*48, "x");
								top = false;
						}
					}
					if (bottom !== false) {
						if (collisionCheck[rawData[i+1][j]] != undefined || collisionCheck[target] == undefined || j == rawData[i].length-1) {
							console.log("BOT", i, bottom);
							if (j == rawData[i].length-1 && collisionCheck[rawData[i+1][j]] == undefined) {
								j++;
							}
							box.addCollision(bottom*48, (i+1)*48, (j-bottom)*48, "x");
							bottom = false;
						}
					}
					/*if (collisionCheck[rawData[i][j]] != undefined) {
						if (start === false) {
							start = j;
						} else if (j == rawData[i].length-1){
							if (start !== false) {
								box.addCollision(start*48, i*48, (j-start+1)*48, "x");
								box.addCollision(start*48, (i+1)*48, (j-start+1)*48, "x");
								start = false;
							}
						}
					} else {
						if (start !== false) {
							box.addCollision(start*48, i*48, (j-start)*48, "x");
							box.addCollision(start*48, (i+1)*48, (j-start)*48, "x");
							start = false;
						}
					}*/
				}
			}
			/*for (var i = 0; i < rawData.length; i++) {
				var start = false;
				for (var j = 0; j < rawData[i].length;j++) {
					if (collisionCheck[rawData[j][i]] != undefined) {
						if (start === false) {
							start = j;
						} else if (j == rawData[i].length-1){
							if (start !== false) {
								box.addCollision(i*48, start*48, (j-start+1)*48, "y");
								box.addCollision((i+1)*48, start*48, (j-start+1)*48, "y");
								start = false;
							}
						}
					} else {
						if (start !== false) {
								box.addCollision(i*48, start*48, (j-start)*48, "y");
								box.addCollision((i+1)*48, start*48, (j-start)*48, "y");
							start = false;
						}
					}
				}
			}*/
			/*for (var i = 0; i < rawData.length; i++) {
				var left = false;
				var right = false;
				for (var j = 0; j < rawData[i].length;j++) {
					if (collisionCheck[rawData[j][i]] != undefined) {
						if (start === false) {
							start = j;
						} else if (j == rawData[i].length-1){
							if (start !== false) {
								box.addCollision(i*48, start*48, (j-start+1)*48, "y");
								box.addCollision((i+1)*48, start*48, (j-start+1)*48, "y");
								start = false;
							}
						}
					} else {
						if (start !== false) {
								box.addCollision(i*48, start*48, (j-start)*48, "y");
								box.addCollision((i+1)*48, start*48, (j-start)*48, "y");
							start = false;
						}
					}
				}
			}*/
		}
		/*class collision{
			constructor(){
				this.allWalls = arguments;
			}
		}*/
		var fps = document.getElementById("FPS");
		function testLoop(func, time){
			setTimeout(()=>{
				var temp = Date.now();
				//fps.innerHTML = Math.round(1000/(temp-time));
				testLoop(func, temp);
			}, 1000/60);
			func();
		}
		var update = ()=>{
			canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
			var temp = Object.getOwnPropertySymbols(ENTITY);
			fps.innerHTML = temp.length;				
			//canvas.ctx.drawImage(art["download2.png"], 0, 0);
			for (var i = 0; i < temp.length; i++) {
				ENTITY[temp[i]].draw(canvas.ctx);
			}
			//console.log("LOL");
		}				
		function rand(min, max) {
			if (min === max) return max;
			return Math.round(Math.random()*(max-min) + min);
		}
		function rng(min, max, excludeMin, excludeMax) {
			var low = excludeMin-min;
			var high = max-excludeMax;
			var random = Math.round(this.rand(0, low+high+1));
			if (random >= 0 && random <= low) {
				return random+min;
			} else if (random > low && random <= low+high+1) {
				return random-low+excludeMax;
			}
		}
			//var canvas = canvasGen();
	var canvas = new layer((window.innerWidth-15*Math.floor(window.innerHeight/15))/2, 1, 15*Math.floor(window.innerHeight/15), 15*Math.floor(window.innerHeight/15));
	canvas.element.style["z-index"] = 0;	
		class wall {
			constructor(x, y, distance, direction, OBJ){
				this.x = x;
				this.y = y;
				this.distance = distance;
				if (direction === 'x') {
					this.check = (x, dist, y1, y2, onImpact)=>{
						var bounds = [this.x, this.x+this.distance];
						if (!((bounds[0] < x || bounds[0] < x+dist) && (x < bounds[1] || x+dist < bounds[1]))) return {y:y2, impact: false};
						if (y1>y2) {
							if (y1 >= this.y && this.y > y2) return {y:this.y, impact:OBJ};
						} else {
							if (y2 >= this.y && this.y > y1) return {y:this.y, impact:OBJ};
						}
						return {y:y2, impact: false};

					};
				} else if (direction === 'y') {
					this.check = (y, dist, x1, x2, onImpact)=>{
						//console.log(y,x1,x2);
						var bounds = [this.y, this.y+this.distance];
						if (!((bounds[0] < y || bounds[0] <y+dist) && (y < bounds[1] || y+dist < bounds[0]))) return {x:x2, impact: false};
						if (x1>x2) {
							if (x1 >= this.x && this.x > x2) return {x:this.x, impact:OBJ}; // limit
						}
						else {
							if(x2 >= this.x && this.x > x1) return {x:this.x, impact:OBJ};
						}
						return {x:x2, impact: false};
					};	
				}
			}
		}	
		async function start(){			
			document.addEventListener("contextmenu", (e)=>e.preventDefault());
			var art = await loadImages(["test.png", "testBack.png", "enemy.png", "enemyBack.png", "target.png", "newEnemy.png", "orb.png", "download3.png"]);
			var lvl1 = new layer((window.innerWidth-15*Math.floor(window.innerHeight/15))/2, 1, 15*Math.floor(window.innerHeight/15), 15*Math.floor(window.innerHeight/15), art["download3.png"]);

			var mainPlayer = new player([art["test.png"], art["testBack.png"]], 300, 300, 36, 40, 6, 8, 48,48);
			//var box = new collisionEntity(0,0, 703, 703);
			//box.addCollision(0,0,canvas.width, "x");
			//box.addCollision(0,0,canvas.height, "y");
			//box.addCollision(0,canvas.height,canvas.width, "x");
			//box.addCollision(canvas.width,0,canvas.height, "y");
			box.prop["type"] = "wall";
			var drawCollision = ()=>{
				var xDir = box.colArea.x;
				var yDir = box.colArea.y;
				for (var i = 0; i < xDir.length; i++) {
					var temp = xDir[i];
					lvl1.ctx.fillStyle = 'red';
					lvl1.ctx.fillRect(temp.x-1, temp.y,2, temp.distance);
				}
				for (var i = 0; i < yDir.length; i++) {
					var temp = yDir[i];
					lvl1.ctx.fillStyle = 'blue';
					lvl1.ctx.fillRect(temp.x, temp.y-1,temp.distance,2);
				}
			};
			mainPlayer.oncollision((c, o)=>{if(o.prop["type"] == "wall") console.log()});
			mainPlayer.speed = 4;			
			mainPlayer.onCursorMove("face", (mouse, playerData)=>{
				if (playerData.moving()) return;
				if (mouse.y-32 < mainPlayer.y) playerData.index = 1;
				else playerData.index = 0;				
			});
			mainPlayer.onmove("KeyS", 1, "y", 0, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});
			mainPlayer.onmove("KeyW", -1, "y", 1, false, ()=>{
				mainPlayer.mouseControls.face.exe();
			});			
			mainPlayer.onmove("KeyA", -1, "x", null, false, false);
			mainPlayer.onmove("KeyD", 1, "x", null, false, false);	
			mainPlayer.onCursorClick("leftClick", "left", 1000/60, (mouse, playerData)=>{
				var temp = new entity([art["orb.png"]], playerData.x+32-4, playerData.y+32-4, 8, 8, 4, 4);
				//Offset height - offset
				temp.oncollision((c, o)=>{if(o.prop["type"] == "wall") c.destroy();});
				temp.moveTo(mouse.x-4-canvas.x, mouse.y-4-canvas.y, ()=>{});
				temp.speed = 10;
			}, false);
			testLoop(()=>{requestAnimationFrame(update);}, 0);
					readMap(testData, collisionTest);
					drawCollision();
		}
		start();
	</script>
</body>
</html>